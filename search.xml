<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[我是那只等爱的狐狸（小王子）]]></title>
    <url>%2Fdigest%2F%E6%88%91%E6%98%AF%E9%82%A3%E5%8F%AA%E7%AD%89%E7%88%B1%E7%9A%84%E7%8B%90%E7%8B%B8%2F</url>
    <content type="text"><![CDATA[今天在敲代码的时候，无意间听到了一首音乐《before it gets dark》，第一条评论是这样的：“我是那只等爱的狐狸。” 于是，我找到了这篇文章： 小王子遇见狐狸，是他正在哭泣的时候。小王子因为难过而邀请狐狸和他一起玩，狐狸拒绝了。 它说:我不能和你玩，因为我还没有被驯养。 它说:对我而言，你只不过是个小男孩，象其他千万个小男孩一样。我不需要你。同样你也用不着我。然而，如果你驯养了我，那么我们就互相不可缺少了。对我来说，你就是世界上唯一的了；对你来说,我也将是世界上唯一的了。 狐狸是执着的。对爱的执着和期待。 驯养，就是建立某种关系。时常，在遇到一些人的时候，脑子里会突然闪现出”请驯养我吧”。对爱情，或者友情，都是需要条件的，如果你驯养了我，那么我们就在一起吧。 小王子驯养了那只狐狸。 狐狸告诉他:你驯养了我，那么我的生命将会充满阳光。你的脚步将会变的和其他人不一样。别人的脚步会让我迅速的躲到地下，而你得脚步声，就象音乐一样，召唤我出洞穴。 多美好的感觉，如果你被驯养，你的世界将不再是原来的样子。 当你爱着我，或者当我爱着你的时候，我们的世界，都不会再是原来的样子。我愿意把我的年华送给你当作新年的祝福，如果你愿意收下的话。 我们不离不弃的牵手一生以后，在生命最后的时光里，你告诉我:请驯养我吧!那将是多么美丽的事情。就算生命正离我们远去，我们的世界依旧是原来的样子。因为我们已经是互相不可缺少的了。 小王子最终还是离开了狐狸，小王子要对他的玫瑰负责。 对于狐狸这样的人来说，生命中其实已不是很介意。一定要把什么东西纂在手心。 小王子说:那你还是什么都没有得到吧? 狐狸说:你看到那边的麦田没有，我不吃面包，麦子对我来说一点用也没有。我对麦田无动于衷。但是，你有着金黄色的头发。麦子，是金色的，它会使我想起你。而且，我也会喜欢风吹麦浪的声音。 原来，爱情或者友情。都是不会计较得失的吧。我不在计较过去的或者将来的得失，可能我一直在失去，可是又有谁不曾已经正在或者将要失去些什么呢？从童年的糖果到生命终结时我们的躯体。 驯养，狐狸，一次又一次的教会我。生命，爱情。执着，以及真诚。 生命就是这样子被激励着，鼓动着。 有谁可以象那只狐狸一样，等待爱，认真的有点固执的等待爱。得到以后，欢乐，但是安静的看者小王子离开。 爱的境界吧，让他快乐就好了。小王子的玫瑰，娇气的玫瑰，也许永远都不会有狐狸的胸襟，可是，它仍旧得到了小王子。或者他没有再回的去，可是那朵玫瑰，依旧是幸福的，至少，小王子曾为她作过挡风的屏障，为她作过玻璃的罩子。 至少，小王子在最后要离开狐狸时仍说:我要对我的玫瑰负责。 我觉得揪心。 我感谢狐狸。于是，在我的生命中，多了一种靠”驯养”建立起来的联系—可能是爱情，也可能是友情，但无论如何，我在去追求的时候，会有这样的心态:我相信，到最后，就算他离开，至少我还会有麦子的颜色。 我想去追求，因为我想要得到。 在得到之前，我说我要好好的爱护我所得到的一切，不给他任何的负担。可是得到了以后，欲望象是一条贪婪的蛇，自私，想据为己有。 也许，爱情本就是自私的。 我们可以分享的东西很多很多，可是如果我们遇到了什么不能分享的东西，我们会不会反目成仇呢?? 狐狸说:至少，我还有麦子的颜色。金色的麦浪会让我想起你。 确实，拥有过，我的世界就会变的和过去不一样，因为你来过，我就不会一无所有。至少我还有麦田的颜色。 有时候，真的不在介意，是否一定要把一些东西纂在手心。 狐狸一定懂得，小王子是理智的有责任感的，他要对玫瑰负责，毕竟狐狸在遇到小王子的时候，他已经有了玫瑰。 请驯服我吧! 我知道,那是爱的声音。 我是那只等爱的狐狸。]]></content>
      <tags>
        <tag>有趣的灵魂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis编写lua脚本]]></title>
    <url>%2Flua%2Fredis%E7%BC%96%E5%86%99lua%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[由于redis并没有类似mysql或者mongo的乐观锁机制，并发控制成了一个棘手的问题这块是可以用redis的watch来做，但是如果能实现乐观锁，那就非常方便了 redis使用lua的基础语法12345&gt; eval "return &#123;KEYS[1],KEYS[2],ARGV[1],ARGV[2]&#125;" 2 key1 key2 first second1) "key1"2) "key2"3) "first"4) "second" lua可以调用的redis函数12redis.call()redis.pcall() 简单例子123456789local version = redis.call("INCR", KEYS[2])if version == 1 then redis.call("EXPIRE", KEYS[2], ARGV[3])end;if tostring(version) ~= ARGV[2] then return &#123;-1, version&#125;end;return redis.call("SET", KEYS[1], ARGV[1]) 运行方式：1redis-cli EVAL "$(cat ./helloWorld.lua)" 3 mykey version1 expire 1 1 100 redis并发控制123456789101112131415161718192021222324252627282930313233343536373839// SaveAtomic 并发控制save 默认versionExpire为30秒func (db *RedisDB) SaveAtomic(key string, val interface&#123;&#125;, versionKey string, versionVal int, versionExpire int) (err error) &#123; if versionExpire == 0 &#123; versionExpire = 100 &#125; storeValue, err := db.getStoreValue(val) if err != nil &#123; return &#125; conn := db.Option.Pool.Get() defer conn.Close() if err = conn.Err(); err != nil &#123; return err &#125; script := `local version = redis.call("INCR", KEYS[2])if version == 1 then redis.call("EXPIRE", KEYS[2], ARGV[3])end;if tostring(version) ~= ARGV[2] then return &#123;-1, version&#125;end;return redis.call("SET", KEYS[1], ARGV[1])` getScript := redis.NewScript(3, script) res, err := redis.String(getScript.Do(conn, key, versionKey, "expire", storeValue, versionVal, versionExpire)) if err != nil &#123; utils.Error(err) return &#125; if res == "-1" &#123; //err = ErrConflict &#125;redis return&#125; 相关文档Redis 命令参考 · lua 脚本]]></content>
      <tags>
        <tag>lua</tag>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[goland 快捷键]]></title>
    <url>%2Fide%2Fgoland%20%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[Mac键盘符号和修饰键说明123456789101112131415161718⌘ Command⇧ Shift⌥ Option⌃ Control↩︎ Return/Enter⌫ Delete⌦ 向前删除键（Fn+Delete）↑ 上箭头↓ 下箭头← 左箭头→ 右箭头⇞ Page Up（Fn+↑）⇟ Page Down（Fn+↓）Home Fn + ←End Fn + →⇥ 右制表符（Tab键）⇤ 左制表符（Shift+Tab）⎋ Escape (Esc) 一、Editing（编辑）123456789101112131415161718192021222324252627282930313233343536373839Control + Space 基本的代码补全（补全任何类、方法、变量）Control + Shift + Space 智能代码补全（过滤器方法列表和变量的预期类型）Command + Shift + Enter 自动结束代码，行末自动添加分号Command + P 显示方法的参数信息Control + J 快速查看文档Shift + F1 查看外部文档（在某些代码上会触发打开浏览器显示相关文档）Command + 鼠标放在代码上 显示代码简要信息Command + F1 在错误或警告处显示具体描述信息Command + N, Control + Enter, Control + N 生成代码（getter、setter、构造函数、hashCode/equals,toString）Control + O 覆盖方法（重写父类方法）Control + I 实现方法（实现接口中的方法）Command + Option + T 包围代码（使用if..else, try..catch, for, synchronized等包围选中的代码）Command + / 注释/取消注释与行注释Command + Option + / 注释/取消注释与块注释Option + 方向键上 连续选中代码块Option + 方向键下 减少当前选中的代码块Control + Shift + Q 显示上下文信息Option + Enter 显示意向动作和快速修复代码Command + Option + L 格式化代码Control + Option + O 优化importControl + Option + I 自动缩进线Tab / Shift + Tab 缩进代码 / 反缩进代码Command + X 剪切当前行或选定的块到剪贴板Command + C 复制当前行或选定的块到剪贴板Command + V 从剪贴板粘贴Command + Shift + V 从最近的缓冲区粘贴Command + D 复制当前行或选定的块Command + Delete 删除当前行或选定的块的行Control + Shift + J 智能的将代码拼接成一行Command + Enter 智能的拆分拼接的行Shift + Enter 开始新的一行Command + Shift + U 大小写切换Command + Shift + ] / Command + Shift + [ 选择直到代码块结束/开始Option + Fn + Delete 删除到单词的末尾Option + Delete 删除到单词的开头Command + 加号 / Command + 减号 展开 / 折叠代码块Command + Shift + 加号 展开所以代码块Command + Shift + 减号 折叠所有代码块Command + W 关闭活动的编辑器选项卡 二、Search/Replace（查询/替换）123456789Double Shift 查询任何东西Command + F 文件内查找Command + G 查找模式下，向下查找Command + Shift + G 查找模式下，向上查找Command + R 文件内替换Command + Shift + F 全局查找（根据路径）Command + Shift + R 全局替换（根据路径）Command + Shift + S 查询结构（Ultimate Edition 版专用，需要在Keymap中设置）Command + Shift + M 替换结构（Ultimate Edition 版专用，需要在Keymap中设置） 三、Usage Search（使用查询）123Option + F7 / Command + F7 在文件中查找用法 / 在类中查找用法Command + Shift + F7 在文件中突出显示的用法Command + Option + F7 显示用法 四、Compile and Run（编译和运行）1234567Command + F9 编译ProjectCommand + Shift + F9 编译选择的文件、包或模块Control + Option + R 弹出 Run 的可选择菜单Control + Option + D 弹出 Debug 的可选择菜单Control + R 运行Control + D 调试Control + Shift + R, Control + Shift + D 从编辑器运行上下文环境配置 五、Debugging（调试）123456789F8 进入下一步，如果当前行断点是一个方法，则不进入当前方法体内F7 进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中Shift + F7 智能步入，断点所在行上有多个方法调用，会弹出进入哪个方法Shift + F8 跳出Option + F9 运行到光标处，如果光标前有其他断点会进入到该断点Option + F8 计算表达式（可以更改变量值使其生效）Command + Option + R 恢复程序运行，如果该断点下面代码还有断点则停在下一个断点上Command + F8 切换断点（若光标当前行有断点则取消断点，没有则加上断点）Command + Shift + F8 查看断点信息 六、Navigation（导航）1234567891011121314151617181920212223242526272829303132Command + O 查找类文件Command + Shift + O 查找所有类型文件、打开文件、打开目录，打开目录需要在输入的内容前面或后面加一个反斜杠/Command + Option + O 前往指定的变量 / 方法Control + 方向键左 / Control + 方向键右 左右切换打开的编辑tab页F12 返回到前一个工具窗口Esc 从工具窗口进入代码文件窗口Shift + Esc 隐藏当前或最后一个活动的窗口，且光标进入代码文件窗口Command + Shift + F4 关闭活动run/messages/find/... tabCommand + L 在当前文件跳转到某一行的指定处Command + E 显示最近打开的文件记录列表Option + 方向键左 / Option + 方向键右 光标跳转到当前单词 / 中文句的左 / 右侧开头位置Command + Option + 方向键左 / Command + Option + 方向键右 退回 / 前进到上一个操作的地方Command + Shift + Delete 跳转到最后一个编辑的地方Option + F1 显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择(如在代码编辑窗口可以选择显示该文件的Finder)Command + B / Command + 鼠标点击 进入光标所在的方法/变量的接口或是定义处Command + Option + B 跳转到实现处，在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口Option + Space, Command + Y 快速打开光标所在方法、类的定义Control + Shift + B 跳转到类型声明处Command + U 前往当前光标所在方法的父类的方法 / 接口定义Control + 方向键下 / Control + 方向键上 当前光标跳转到当前文件的前一个/后一个方法名位置Command + ] / Command + [ 移动光标到当前所在代码的花括号开始/结束位置Command + F12 弹出当前文件结构层，可以在弹出的层上直接输入进行筛选（可用于搜索类中的方法）Control + H 显示当前类的层次结构Command + Shift + H 显示方法层次结构Control + Option + H 显示调用层次结构F2 / Shift + F2 跳转到下一个/上一个突出错误或警告的位置F4 / Command + 方向键下 编辑/查看代码源Option + Home 显示到当前文件的导航条F3选中文件/文件夹/代码行，添加/取消书签Option + F3 选中文件/文件夹/代码行，使用助记符添加/取消书签Control + 0...Control + 9 定位到对应数值的书签位置Command + F3 显示所有书签 七、Refactoring（重构）1234567891011F5 复制文件到指定目录F6 移动文件到指定目录Command + Delete 在文件上为安全删除文件，弹出确认框Shift + F6 重命名文件Command + F6 更改签名Command + Option + N 一致性Command + Option + M 将选中的代码提取为方法Command + Option + V 提取变量Command + Option + F 提取字段Command + Option + C 提取常量Command + Option + P 提取参数 八、VCS/Local History（版本控制/本地历史记录）1234Command + K 提交代码到版本控制器Command + T 从版本控制器更新代码Option + Shift + C 查看最近的变更记录Control + C 快速弹出版本控制器操作面板 九、Live Templates（动态代码模板）12Command + Option + J 弹出模板选择窗口，将选定的代码使用动态模板包住Command + J 插入自定义动态代码模板 十、General（通用）123456789101112Command + 1...Command + 9 打开相应编号的工具窗口Command + S 保存所有Command + Option + Y 同步、刷新Control + Command + F 切换全屏模式Command + Shift + F12 切换最大化编辑器Option + Shift + F 添加到收藏夹Option + Shift + I 检查当前文件与当前的配置文件Control + ` 快速切换当前的scheme（切换主题、代码样式等）Command + , 打开IDEA系统设置Command + ; 打开项目结构对话框Shift + Command + A 查找动作（可设置相关选项）Control + Shift + Tab 编辑窗口标签和工具窗口之间切换（如果在切换的过程加按上delete，则是关闭对应选中的窗口） 十一、Other（一些官方文档上没有体现的快捷键）1Command + Shift +8 竖编辑模式]]></content>
      <tags>
        <tag>ide</tag>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件操作]]></title>
    <url>%2Fpython%2F%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[判断是文件还是文件夹1234567import osif os.path.isdir(path): print &quot;it&apos;s a directory&quot;elif os.path.isfile(path): print &quot;it&apos;s a normal file&quot;else: print &quot;it&apos;s a special file(socket,FIFO,device file)&quot; 判断文件是否存在123456import os &gt;&gt;&gt; os.path.exists(&apos;d:/assist&apos;) True&gt;&gt;&gt; os.path.exists(&apos;d:/assist/getTeacherList.py&apos;) True 获取文件大小123import os os.path.getsize(path)]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[性能监控]]></title>
    <url>%2Fmongodb%2F%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%2F</url>
    <content type="text"><![CDATA[拿阿里云MongoDB举例 mongotop1mongotop -h dds-****.mongodb.rds.aliyuncs.com:3717 -u root -p **** --authenticationDatabase admin 10 mongostat12mongostat -h dds-****.mongodb.rds.aliyuncs.com:3717 -u root -p **** --authenticationDatabase adminmongostat --host 100.100.100.100 -u root -p **** --authenticationDatabase admin]]></content>
      <tags>
        <tag>mongo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[命令行参数]]></title>
    <url>%2Flinux%2F%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[特殊变量列表 $0 当前脚本的文件名 $n 传递给脚本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是$1，第二个参数是$2。 $# 传递给脚本或函数的参数个数。 $* 传递给脚本或函数的所有参数。 $@ 传递给脚本或函数的所有参数。被双引号(“ “)包含时，与 $* 稍有不同，下面将会讲到。 $? 上个命令的退出状态，或函数的返回值。 $$ 当前Shell进程ID。对于 Shell 脚本，就是这些脚本所在的进程ID。 $* 和 $@ 的区别$* 和 $@ 都表示传递给函数或脚本的所有参数，不被双引号(“ “)包含时，都以”$1” “$2” … “$n” 的形式输出所有参数。 但是当它们被双引号(“ “)包含时，”$*” 会将所有的参数作为一个整体，以”$1 $2 … $n”的形式输出所有参数；”$@” 会将各个参数分开，以”$1” “$2” … “$n” 的形式输出所有参数。 下面的例子可以清楚的看到 $* 和 $@ 的区别：12345678910111213141516171819202122232425#!/bin/bashecho "\$*=" $*echo "\"\$*\"=" "$*"echo "\$@=" $@echo "\"\$@\"=" "$@"echo "print each param from \$*"for var in $*doecho "$var"doneecho "print each param from \$@"for var in $@doecho "$var"doneecho "print each param from \"\$*\""for var in "$*"doecho "$var"doneecho "print each param from \"\$@\""for var in "$@"doecho "$var"done 执行 ./test.sh “a” “b” “c” “d”，看到下面的结果：123456789101112131415161718192021$*= a b c d&quot;$*&quot;= a b c d$@= a b c d&quot;$@&quot;= a b c dprint each param from $*abcdprint each param from $@abcdprint each param from &quot;$*&quot;a b c dprint each param from &quot;$@&quot;abcd 退出状态$? 可以获取上一个命令的退出状态。所谓退出状态，就是上一个命令执行后的返回结果。 退出状态是一个数字，一般情况下，大部分命令执行成功会返回 0，失败返回 1。 不过，也有一些命令返回其他值，表示不同类型的错误。]]></content>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[清除本地所有修改]]></title>
    <url>%2Fgit%2Fgit%20%E6%B8%85%E9%99%A4%E6%9C%AC%E5%9C%B0%E6%89%80%E6%9C%89%E4%BF%AE%E6%94%B9%2F</url>
    <content type="text"><![CDATA[本地修改了许多文件，其中有些是新增的，因为开发需要这些都不要了，想要丢弃掉，可以使用如下命令： 方案112345678910git checkout . #本地所有修改的。没有的提交的，都返回到原来的状态git stash #把所有没有提交的修改暂存到stash里面。可用git stash pop回复。git reset --hard HASH #返回到某个节点，不保留修改。git reset --soft HASH #返回到某个节点。保留修改git clean -df #返回到某个节点git clean 参数 -n 显示 将要 删除的 文件 和 目录 -f 删除 文件 -df 删除 文件 和 目录 方案21git checkout . &amp;&amp; git clean -xdf]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多账号]]></title>
    <url>%2Fgit%2F%E5%A4%9A%E8%B4%A6%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[首先说一下账号切换 首先我现在有一个github账号叫A,但是我现在不想用这个账号了，于是我在github上面重新申请了一个账号叫B，我在B账号下新建了一个仓库，然后使用命令行上传我的本地代码出现以下错误12remote: Permission to B/test.git denied to Afatal: unable to access &apos;https://github.com/B/test/&apos;: The requested eror: 403 原因是Mac电脑上的钥匙串，每次我们设置好用户名和密码都会自动存储到Mac的钥匙串上面，每次使用命令行上传代码的时候，Mac会自动填充A账号和密码 这时候我只需要打开钥匙串，然后搜索git，把有关Github的账号密码都删除掉。就可以 此处省略1万字的草泥马。。。]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Programming in Lua摘录]]></title>
    <url>%2Fdigest%2F%E7%A2%A7%E8%A1%80%E5%89%91%2F</url>
    <content type="text"><![CDATA[“袁承志知道若再谦逊，那就是瞧人不起，展开五行拳，发拳当胸打去。荣彩和旁观三人本来都以为他武功有独到之秘，哪知使出来的竟是武林中最寻常不过的五行拳。 敌对三人登时意存轻视，温青脸上不自禁露出失望的神色。 “荣彩心中暗喜，双拳如风，连抢三下攻势，满拟自己的大力魔爪手江南独步，三四招之间就可破去对方五行拳，那知袁承志轻描淡写的一一化解。再拆数招，荣彩暗暗吃惊，原来对方所使虽是极寻常的拳术，但每一招均是含劲不吐，意在拳先，举手抬足 之间隐含极浑厚的内力。” ——金庸《碧血剑》]]></content>
      <tags>
        <tag>有趣的灵魂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[峰终定律]]></title>
    <url>%2Fdigest%2F%E5%B3%B0%E7%BB%88%E5%AE%9A%E5%BE%8B%2F</url>
    <content type="text"><![CDATA[介绍诺贝尔奖得主，心理学家DanielKahneman，经过深入研究，发现对体验的记忆由两个因素决定：高峰（无论是正向的还是负向的）时与结束时的感觉，这就是峰终定律（Peak-EndRule）。这条定律基于潜意识总结体验的特点：对一项事物的体验之后，所能记住的就只是在峰与终时的体验，而在过程中好与不好体验的比重、好与不好体验的时间长短，对记忆差不多没有影响。而这里的“峰”与“终”其实这就是所谓的“关键时刻MOT”，MOT(MomentofTruth)是服务界最具震撼力与影响力的管理概念与行为模式 例子一批人去做直肠检查的时候，分成两批人做实验 第一批人将器械放入直肠检查10分钟，病人忍受艰难的10分钟，然后立刻拔出 第二批人将器械放入直肠检查10分钟，病人忍受艰难的10分钟，医生出去办事，忘了拔出来了，等回来之后才拔出来，病人在痛苦中逐渐麻木。 事后询问这两批人，如果下次生病还要不要做这种检查。 第二批人的态度普遍比第一批人好一些，表示愿意接受这种检查方式。 这就是典型的峰终定律]]></content>
      <tags>
        <tag>有趣的灵魂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[名词记录]]></title>
    <url>%2Fdigest%2F%E5%90%8D%E8%AF%8D%2F</url>
    <content type="text"><![CDATA[名词：峰终效应小数定律舒适的环境很容易让人用第一种方式思考问题，就像押韵的诗，印刷良好的书沉锚效应回归效应事前验尸，过度乐观，规划谬误]]></content>
      <tags>
        <tag>有趣的灵魂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[思考·快与慢摘录]]></title>
    <url>%2Fdigest%2F%E6%80%9D%E8%80%83%C2%B7%E5%BF%AB%E4%B8%8E%E6%85%A2%2F</url>
    <content type="text"><![CDATA[两个思维系统在我们的大脑中，存在着两个思维系统，丹尼尔·卡尼曼命名它们为系统1（快思考）和系统2（慢思考）。 系统1系统1 就像大脑的自动反应模式，会根据生活经验总结无数下意识反应的套路，使生活简化，让我们不必每天早上起来都思考一遍如何套上衣服、扣纽扣、拧开牙膏盖、挤牙膏…… 系统1把生活中的很多事情都变成可一键执行的自动程序，节省我们日常生活中的脑力损耗。 系统1也能够察觉一些简单的关系，比如“这两个杯子的外型是一样的”、“哥哥比弟弟高一点”……但是它无法处理多个独立话题。 它可以快速反应出“2+7=9”，但是遇到“27×56=？”这类复杂的问题就会立地蒙圈儿，无法给出答案，而所有令它蒙圈儿的事情，就会移交给系统2处理。 系统2系统2接到系统1的求助后，就将大脑的注意力分配到系统1碰到的难题上，集中精神处理该问题。 值得注意的是，系统2的所有运作都需要集中注意力，一旦注意力分散，运作也会随之中断。 就像你在散步的时候可以天马行空地随便想一些东西，但如果此时有人请你解决一个复杂的问题，比如“请用5分钟浏览这本书并概括书籍主旨”，此时你往往会发现自己散步的脚停了下来。 因为人的注意力是有限的，系统2会将它们优先使用在当前遇到的难题之上，同样的道理，假如你以极快的步速散步，你也会发现因为需要更快辨别更多眼前转换的景物，你就无法同时在脑中盘算事情。 系统2十分谨慎，具有推理能力，它也可以处理多重任务，这就决定了通过系统2运作得出的结论往往更靠谱。 系统1和系统2的协作如上文所述，我们知道，当某样事物令系统1蒙圈儿，违反了系统1熟悉的模式，系统2会被激活。这告诉我们：系统2是非常懒惰的，它通常不会主动干预系统1的工作，除非系统1发出求助。 而系统1是全天候24小时在线，且无法关闭的。这就决定了我们在处理事情的时候，总是系统1先出面，而不能绕过系统1直接面对系统2。因此当系统1认为自己可以处理问题并给出答案时，就没有系统2什么事了。 这种配合模式使它们的协作非常高效，能花最少力气解决问题的绝不多费一分脑力。 而系统1也很善于完成自己的本职工作：它在熟悉的情境中采用的套路是精确的，所作出的短期预测是准确的，遇到挑战时做出的第一反应也是迅速且基本恰当的。但是它也因经验而存在成见，因此经常犯错。 系统2也负责抑制系统1因直觉反应产生的冲动，一个典型的例子就是每个人应该都有过强忍着不诅咒别人去死的经历。但它通常的做法是不加验证地同意系统1的解决方案。 并且，根据心理学家的多项实验证明，当系统2在忙着处理某些难题时，系统1更容易把控人的行为。 ——这些就导致我们做出的很多决策其实都是依赖系统1的直觉反应，而不是经过系统2的理性分析与计算的——但对于这点，我们甚至都一无所知。 大脑思考机制引发的心理学效应由于系统1和系统2的这种运作模式，导致我们常跟着直觉走而不自知，心理学家们为这些非理性决策而着迷，在经过了大量的实验研究后，他们发现了诸多建立在直觉思维上的有趣现象： 曝光效应系统1对出现过的人、事、物会产生熟悉感，然后根据这种熟悉感作出判断。 因系统1的熟悉感，我们所产生的对此物或此事放松的感觉就是认知放松。 当某个人、某句话、某样事物频繁出现，反复在我们面前曝光自己，就会引发认知放松，进而更容易被判定为可信的。 这种只要经常出现就能增加喜欢程度的现象就被叫做曝光效应，或者纯粹接触效应。 沉锚效应沉锚效应，心理学名词，指的是人们在对某人某事做出判断时，易受第一印象或第一信息支配，就像沉入海底的锚一样把人们的思想固定在某处。作为一种心理现象，沉锚效应普遍存在于生活的方方面面。第一印象和先入为主是其在社会生活中的表现形式。 通常来讲，人们在作决策时，思维往往会被得到的第一信息所左右，就像沉入海底的锚一样，把你的思维固定在某处。而用一个限定性的词语或规定作行为导向，达成行为效果的心理效应，被称为“沉锚效应”。]]></content>
      <tags>
        <tag>有趣的灵魂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[索引]]></title>
    <url>%2Fmysql%2Findex%2F</url>
    <content type="text"><![CDATA[查询索引1234SHOW &#123;INDEX | INDEXES | KEYS&#125; &#123;FROM | IN&#125; tbl_name [&#123;FROM | IN&#125; db_name] [WHERE expr] 例子：12SHOW INDEX FROM mydb.mytable;show index from authority; 字段较多时，竖着看更清晰1SHOW INDEX FROM mydb.mytable\G; 创建索引直通车：https://dev.mysql.com/doc/refman/5.7/en/create-index.html1234567891011121314151617181920212223CREATE [UNIQUE | FULLTEXT | SPATIAL] INDEX index_name [index_type] ON tbl_name (key_part,...) [index_option] [algorithm_option | lock_option] ...key_part: col_name [(length)] [ASC | DESC]index_option: KEY_BLOCK_SIZE [=] value | index_type | WITH PARSER parser_name | COMMENT 'string'index_type: USING &#123;BTREE | HASH&#125;algorithm_option: ALGORITHM [=] &#123;DEFAULT | INPLACE | COPY&#125;lock_option: LOCK [=] &#123;DEFAULT | NONE | SHARED | EXCLUSIVE&#125; 例子：1CREATE INDEX id_index ON lookup (id) USING BTREE; 删除索引语法使用的alert，比较复杂，这儿只放一个链接https://dev.mysql.com/doc/refman/5.7/en/alter-table.html 例子：1alter table authority drop index UQE_authority_page; 联合索引联合索引又叫复合索引。对于复合索引:Mysql从左到右的使用索引中的字段，一个查询可以只使用索引中的一部份，但只能是最左侧部分。例如索引是key index (a,b,c). 可以支持a | a,b| a,b,c 3种组合进行查找，但不支持 b,c进行查找 .当最左侧字段是常量引用时，索引就十分有效。 例子：123show index from authority;alter table authority drop index UQE_authority_page;CREATE index UQE_authority_page on authority(company_id,page);]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[拼接新的变量名]]></title>
    <url>%2Flinux%2Feval%2F</url>
    <content type="text"><![CDATA[##shell变量作为另一个变量名 使用eval123#!/bin/shi=1eval echo '$'rediscache$i 例1：123dev@pirate-test:~chimps (master *%) $ i=1 dev@pirate-test:~chimps (master *%) $ eval echo '$'rediscache$i10.100.100.100 例21234567#!/bin/shfor ((i = 1; i &lt; 60; i++)); do redis=$(eval echo &apos;$&apos;rediscache$i) count=$(redis-cli -h $redis -a ***** DEL key1) echo &#123;idx:,$i,redis:,$redis,count:,$count&#125;done]]></content>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[优秀一点点]]></title>
    <url>%2Fdigest%2F%E5%BC%82%E7%B1%BB%E6%91%98%E5%BD%95%2F</url>
    <content type="text"><![CDATA[在社会学领域，所谓成功就是“优势积累”的结果。 职业冰球队员一开始只比最初所在球队的队友好一点点，然而这微小的优势带来的机遇，扩大了他和那些队友之间的差距，随后差距与机会交替发挥作用，微小的差距被越拉越大——最终被选中的队员成了真正出众的天才。 由此可以看出，天才并非一开始就表现出众，一开始他只是比别人优秀那么一点点。]]></content>
      <tags>
        <tag>有趣的灵魂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[承认病态的自我]]></title>
    <url>%2Fdigest%2F%E5%B0%91%E6%9C%89%E4%BA%BA%E8%B5%B0%E7%9A%84%E8%B7%AF2%2F</url>
    <content type="text"><![CDATA[承认病态的自我需要勇气，佛教有一句名言：海无边，回头是岸 圣人改变的是自己，走的是一条修行的路。通过完善自己，可以感召别人，唤醒别人的良知，给别人指引。 与之相反，由于大恶之人害怕改变自己，所以便去改变别人，他们不择手段去控制别人，压制别人，甚至毁灭别人的生命。]]></content>
      <tags>
        <tag>有趣的灵魂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[放弃自由]]></title>
    <url>%2Fdigest%2F%E5%B0%91%E6%9C%89%E4%BA%BA%E8%B5%B0%E7%9A%84%E8%B7%AF1%2F</url>
    <content type="text"><![CDATA[今天读的一章为：过分依赖集体，个人的心智就会退化 推理很到位： “自然赋予人自由意志，也就是赋予了人自主选择的权利。人生是有一个接一个的选择组成的，不同的选择导致不同的人生。但是不可否认的是，伴随着自主选择，人也就多了更多的烦恼和痛苦。选择是一件令人烦恼和痛苦的事情。首先选择意味着放弃。选择一条路，意味着放弃其他的路；有了一个选择，意味着要放弃其他选择。由于人们不愿意放弃，所以每当面临选择时，内心总是充满烦恼和痛苦。其次，选择会产生结果，人们必须为自己的选择负责，并承受选择所带来的结果。当然，好的结果令人欣喜，但坏的结果不仅会招致别人的指责、埋怨，也会让自己陷入懊恼和自责之中，令人痛苦不堪。许多人不愿意承受选择所带来的痛苦，便会把自主选择的权利拱手让给他人。这就是弗洛姆所说的逃避自由。 逃避自由的人放弃了自主选择的权利，也就放弃了独立思考的能力，这意味着他们将失去独立的自我，失去自己的灵魂。一个没有灵魂的人就像一张破碎的纸片，盲目地追随着每一阵风，完全失去了掌控自我的能力，最终会成为魔鬼撒旦的工具，干出许多邪恶的事情。” 我感觉说的很对，想想和以前和朋友一块儿的时候，有什么事情都是让对方做选择，虽然会让别人会觉得你随和，为他人着想。实际上是自己太多胆小，不敢承担选择所带来的风险。是因为怕，才放弃了自主思考的权利，给人一种没有底气，没有底线的感觉。]]></content>
      <tags>
        <tag>有趣的灵魂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[人性的弱点摘录]]></title>
    <url>%2Fdigest%2F%E4%BA%BA%E6%80%A7%E7%9A%84%E5%BC%B1%E7%82%B9%2F</url>
    <content type="text"><![CDATA[在与人相处时，要切记：与我们交往的不是纯粹按道理或逻辑生活的人，而是充满了感情的，带有偏见、傲慢和虚荣的人。]]></content>
      <tags>
        <tag>有趣的灵魂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[定时任务]]></title>
    <url>%2Flinux%2F%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[基本规则12345678minute hour day month week command- minute： 表示分钟，可以是从0到59之间的任何整数。- hour：表示小时，可以是从0到23之间的任何整数。- day：表示日期，可以是从1到31之间的任何整数。- month：表示月份，可以是从1到12之间的任何整数。- week：表示星期几，可以是从0到7之间的任何整数，这里的0或7代表星期日。- command：要执行的命令，可以是系统命令，也可以是自己编写的脚本文件。 特殊字符1234星号（*）：代表所有可能的值，例如month字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。逗号（,）：可以用逗号隔开的值指定一个列表范围，例如，“1,2,5,7,8,9”中杠（-）：可以用整数之间的中杠表示一个整数范围，例如“2-6”表示“2,3,4,5,6”正斜线（/）：可以用正斜线指定时间的间隔频率，例如“0-23/2”表示每两小时执行一次。同时正斜线可以和星号一起使用，例如*/10，如果用在minute字段，表示每十分钟执行一次。 编辑定时任务12crontab -e* * * * * 命令 查看系统定时任务1crontab -l 删除定时任务1crontab -r 服务管理/sbin/service crond start //启动服务/sbin/service crond stop //关闭服务/sbin/service crond restart //重启服务/sbin/service crond reload //重新载入配置 例子每1分钟执行一次command1* * * * * command 每小时的第3和第15分钟执行13,15 * * * * command 在上午8点到11点的第3和第15分钟执行13,15 8-11 * * * command 每隔两天的上午8点到11点的第3和第15分钟执行13,15 8-11 */2 * * command 每个星期一的上午8点到11点的第3和第15分钟执行13,15 8-11 * * 1 command 每晚的21:30重启smb130 21 * * * /etc/init.d/smb restart 每月1、10、22日的4 : 45重启smb145 4 1,10,22 * * /etc/init.d/smb restart 每周六、周日的1:10重启smb110 1 * * 6,0 /etc/init.d/smb restart 每天18 : 00至23 : 00之间每隔30分钟重启smb10,30 18-23 * * * /etc/init.d/smb restart 每星期六的晚上11:00 pm重启smb10 23 * * 6 /etc/init.d/smb restart 每一小时重启smb1* */1 * * * /etc/init.d/smb restart 晚上11点到早上7点之间，每隔一小时重启smb1* 23-7/1 * * * /etc/init.d/smb restart 每月的4号与每周一到周三的11点重启smb10 11 4 * mon-wed /etc/init.d/smb restart 一月一号的4点重启smb10 4 1 jan * /etc/init.d/smb restart]]></content>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL max_allowed_packet设置]]></title>
    <url>%2Fmysql%2Fmax_allowed_packet%2F</url>
    <content type="text"><![CDATA[什么是max_allowed_packetmax_allowed_packet是mysql允许插入一条数据的大小 查看目前配置12345678mysql&gt; show VARIABLES like '%max_allowed_packet%';+--------------------------+------------+| Variable_name | Value |+--------------------------+------------+| max_allowed_packet | 16777216 || slave_max_allowed_packet | 1073741824 |+--------------------------+------------+2 rows in set (0.01 sec) 修改方法 编辑my.cnf文件 1max_allowed_packet=20M 保存重启mysql 如果找不到my.cnf，可以通过命令：mysql --help | grep my.cnf 在mysql 命令行中运行 1set global max_allowed_packet = 2*1024*1024*10 然后关闭掉这此mysql server链接，再进入]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP 上传 下载]]></title>
    <url>%2Fgolang%2Fhttp%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[上传12345678910111213141516171819202122232425262728// 获取form文件file, err := c.FormFile("attachment")if err != nil &#123; return nil, GenError(err)&#125;now := time.Now()// 检查目录dir := fmt.Sprintf("upload/%d%d", now.Year(), now.Month())if !utils.Exists(dir) &#123; err = os.MkdirAll(dir, os.ModePerm) if err != nil &#123; return nil, GenError(err) &#125;&#125;// 创建文件path := fmt.Sprintf("%s/%d%s", dir, now.Unix()%(3600*24*30), file.Filename)out, err := os.Create(path)if err != nil &#123; return nil, GenError(err)&#125;f, err := file.Open()if err != nil &#123; return nil, GenError(err)&#125;_, err = io.Copy(out, f)if err != nil &#123; return nil, GenError(err)&#125; 下载1234567891011121314151617181920212223242526file, err := os.Open(attachment.Path)if err != nil &#123; OnError(c, err) return&#125;defer file.Close()// 读取文件头信息fileHeader := make([]byte, 512)file.Read(fileHeader)fileContentType := http.DetectContentType(fileHeader)fileStat, _ := file.Stat()fileSize := strconv.FormatInt(fileStat.Size(), 10)// 设置response header头，gin框架也可以用c.Header("","")c.Writer.Header().Set("Content-Disposition", "attachment; filename="+attachment.Name)c.Writer.Header().Set("Content-Type", fileContentType)c.Writer.Header().Set("Content-Length", fileSize)// 注意还原io读取指针file.Seek(0, 0)_, err = io.Copy(c.Writer, file)if err != nil &#123; OnError(c, err) return&#125;]]></content>
      <tags>
        <tag>go</tag>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文摘]]></title>
    <url>%2Fdigest%2F%E6%96%87%E6%91%98%2F</url>
    <content type="text"><![CDATA[做人难 “ 海浪卷走了小孩的鞋子，小孩在海滩上写下：大海是小偷！一个男人在海里打捞出了一些好东西，在沙滩上写到：大海真慷慨！ 一少年溺水身亡，他的母亲在海边写了：大海是凶手！ 一个老翁打捞到了珍珠，他写到：大海真仁慈！ …这时一个海浪冲上来抹去了所有的字， 大海平静地说：如果你想成为大海， 就不要在意别人对你的评说！ 因为你做不到让所有人满意。人生如果容易的话，你当初来到这个世界时就不会从哭泣开始！ ” 共勉 喜欢 有一个民谣青年曾说：最单纯的喜欢就是，就算你拒绝了我，我对你也永远没有埋怨。但我不会再靠近了。如果你有求于我，我依然会鞠躬尽瘁。从今往后我会把喜欢藏起来，不再招摇过市了，我会努力过得好，希望你也是。]]></content>
      <tags>
        <tag>有趣的灵魂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zsh]]></title>
    <url>%2Flinux%2Fzsh%2F</url>
    <content type="text"><![CDATA[安装 zsh1sudo apt-get install zsh oh-my-zsh：摘自：https://github.com/robbyrussell/oh-my-zsh 1sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot; 命令高亮摘自：https://github.com/zsh-users/zsh-syntax-highlighting/blob/master/INSTALL.md 123git clone https://github.com/zsh-users/zsh-syntax-highlighting.gitecho &quot;source $&#123;(q-)PWD&#125;/zsh-syntax-highlighting/zsh-syntax-highlighting.zsh&quot; &gt;&gt; $&#123;ZDOTDIR:-$HOME&#125;/.zshrcsource ./zsh-syntax-highlighting/zsh-syntax-highlighting.zsh 可以设置默认sh1sudo chsh -s /bin/zsh]]></content>
      <tags>
        <tag>linux</tag>
        <tag>zsh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[awk]]></title>
    <url>%2Flinux%2Fawk%2F</url>
    <content type="text"><![CDATA[参见linux手册awk部分 示例文本test.txt123456Beth 4.00 0Dan 3.75 0kathy 4.00 10aMark 5.00 20Mary 5.50 22Susie 4.25 18 基本语法示例awk &#39;$3 &gt;0 { print $1, $2 * $3 }&#39; emp.data 通过awk脚本文件test.awk123/.+th/ &#123; print $0&#125; 运行脚本：1234$ awk -f test.awk test.txt# 结果：Beth 4.00 0kathy 4.00 10 BEGIN与END123456789BEGIN&#123; print &quot;begin search&quot;&#125;END&#123; print &quot;all end&quot;&#125;/.+th/&#123; print $0&#125; 运行：123456$ awk -f test.awk test.txt# 结果begin searchBeth 4.00 0kathy 4.00 10all end 内置变量ARGC表示在命令中提供的参数的个数例：1awk &apos;BEGIN &#123;print &quot;Arguments =&quot;, ARGC&#125;&apos; One Two Three Four 结果：Arguments = 5 ARGV这个变量表示存储命令行输入参数的数组,数组的有效索引是从 0 到 ARGC-1例1234567891011BEGIN&#123; for (i = 0; i &lt; ARGC ;i++)&#123; printf &quot;ARGV[%d]=%s\n&quot;, i, ARGV[i] &#125;&#125;END&#123; print &quot;all end&quot;&#125;/.+th/&#123; print $0&#125; 运行：1234567$ awk -f test.awk test.txt# 结果ARGV[0]=awkARGV[1]=test.txtBeth 4.00 0kathy 4.00 10all end ENVISON环境变量12345BEGIN&#123; for (n in ENVIRON)&#123; print n &quot;: &quot; ENVIRON[n] &#125;&#125; 运行：12345678$ awk -f test.awk test.txt# 结果GOROOT: /usr/local/Cellar/go/1.7.4_1/libexecLESS: -RPAGER: lessAWKPATH: .:/usr/local/Cellar/gawk/4.1.4_1/share/awkOLDPWD: ...TERM_PROGRAM: iTerm.app FILENAME文件名123456BEGIN&#123; print FILENAME&#125;END&#123; print FILENAME&#125; 运行：123/chimps/linux/awk awk -f test.awk test.txttest.txt 可以看出在begin的时候FILENAME变量为空值 FS此变量表示输入的数据域之间的分隔符，其默认值是空格。 你可以使用 -F 命令行选项改变它的默认值。 NF此变量表示当前输入记录中域的数量test.txt1234MarksMark 5.00Mary 5.50 22Susie 4.25 18 test.awk123NF&gt;2&#123; print $0&#125; 执行：123/chimps/linux/awk awk -f test.awk test.txtMary 5.50 22Susie 4.25 18 NR（FNR）默认的就是读取的数据行数，NR可以理解为Number of Record的缩写,FNR则为File Number of Record1234567891011# class1:zhaoyun 85 87guanyu 87 88liubei 90 86# class2:caocao 92 87 90guojia 99 96 92# test.awk:&#123; print NR,FNR,$0&#125; 执行：123456/chimps/linux/awk awk -f test.awk class1 class21 1 zhaoyun 85 872 2 guanyu 87 883 3 liubei 90 864 1 caocao 92 87 905 2 guojia 99 96 92 数组操作123456789BEGIN&#123; arr[1] = &quot;zhangsan&quot; arr[&quot;lisi&quot;] = &quot;lisi&quot; arr[2] = &quot;wangwu&quot; for (n in arr)&#123; print arr[n] &#125;&#125; 运行：1234/chimps/linux/awk awk -f test.awk test.txtlisizhangsanwangwu 判断数组中是否存在某一项1234567891011121314BEGIN&#123; arr[&quot;zhangsan&quot;] = &quot;wangwu&quot; if(&quot;zhangsan&quot; in arr)&#123; print &quot;zhangsan ok&quot; &#125;else&#123; print &quot;zhangsan not found&quot; &#125; if(&quot;lisi&quot; in arr)&#123; print &quot;lisi ok&quot; &#125;else&#123; print &quot;lisi not found&quot; &#125;&#125; 运行：123/chimps/linux/awk awk -f deal_err.awkzhangsan oklisi not found DEMO获取每个进程的内存占用test.awk:123456789NR != 1 &amp;&amp; $4 &gt; 0&#123; mem[$4] = $11&#125;END&#123; asorti(mem, Nmem) for (k in Nmem)&#123; print mem[Nmem[k]], Nmem[k] &#125;&#125; 运行：ps aux | awk -f test.awk 多行日志处理file.log：12345678[2017-02-17 16:19:04] [285]&lt;- /v2/api/file/item/476-&gt; &#123;&quot;success&quot;:true,&quot;successInfo&quot;:&#123;&#125;&#125;[2017-03-10 11:57:42] []&lt;- /v2/api/file/diff?fid1=381&amp;fid2=287-&gt; &#123;&quot;success&quot;:false,&quot;errorInfo&quot;:&quot;长度不能为空&quot;,&quot;successInfo&quot;:&#123;&#125;,&quot;debug&quot;:&#123;&quot;line&quot;:37,&quot;info&quot;:null&#125;&#125;... 方式一：使用数组deal_err.awk1234567891011121314151617181920212223242526BEGIN&#123; sub_index = 0&#125;/^\[/&#123; arr_line[sub_index] = $1 &quot;\t&quot; $2&#125;/^&lt;-/&#123; arr_line[sub_index] = arr_line[sub_index] &quot;\t&quot; $2&#125;/^-&gt;/&#123; text = substr($2, 2, length($2)-2) split(text, text_arr, &quot;,&quot;) split(text_arr[1], text_arr1, &quot;:&quot;) if (text_arr1[2] == &quot;false&quot;)&#123; arr[sub_index] = arr_line[sub_index] &quot;\t&quot; text_arr[2] sub_index ++ &#125;&#125;END&#123; for (k in arr) &#123; print k,arr[k] &gt;&gt; &quot;output.txt&quot; &#125;&#125; 运行：1awk -f deal_err.awk file.log 方式二：匹配成功就写到文件deal_err.awk12345678910111213141516/^\[/&#123; url = $1 &quot;\t&quot; $2&#125;/^&lt;-/&#123; request = arr_line[sub_index] &quot;\t&quot; $2&#125;/^-&gt;/&#123; response = substr($2, 2, length($2)-2) split(response, res_arr, &quot;,&quot;) split(res_arr[1], res_arr1, &quot;:&quot;) if (res_arr1[2] == &quot;false&quot;)&#123; print url,request,res_arr[2] &gt; &quot;output.txt&quot; &#125;&#125; 很明显，这样可读性好一些运行：1awk -f deal_err.awk file.log]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ssh无密码登录]]></title>
    <url>%2Flinux%2Fssh%2F</url>
    <content type="text"><![CDATA[ssh无密码登录公钥认证的基本思想对信息的加密和解密采用不同的key，这对key分别称作private key和public key，其中，public key存放在欲登录的服务器上，而private key为特定的客户机所持有。 当客户机向服务器发出建立安全连接的请求时，首先发送自己的public key，如果这个public key是被服务器所允许的，服务器就发送一个经过public key加密的随机数据给客户机，这个数据只能通过private key解密，客户机将解密后的信息发还给服务器，服务器验证正确后即确认客户机是可信任的，从而建立起一条安全的信息通道。 通过这种方式，客户机不需要向外发送自己的身份标志“private key”即可达到校验的目的，并且private key是不能通过public key反向推断出来的。这避免了网络窃听可能造成的密码泄露。客户机需要小心的保存自己的private key，以免被其他人窃取，一旦这样的事情发生，就需要各服务器更换受信的public key列表。 具体实现 用ssh-keygen创建公钥 1234567891011121314151617181920212223242526272829[root@Server1 ~]# ssh-keygen -t rsaGenerating public/private rsa key pair.Enter file in which to save the key(/root/.ssh/id_rsa):Created directory '/root/.ssh'.Enter passphrase (empty for no passphrase):Enter same passphrase again:Your identification has been saved in/root/.ssh/id_rsa.Your public key has been saved in/root/.ssh/id_rsa.pub.The key fingerprint is:7b:aa:08:a0:99:fc:d9:cc:d8:2e:4b:1a:c0:6b:da:e4root@Server1The key's randomart image is:+--[ RSA 2048]----+| || || ||. ||o. S ||++. . ||+=o. . . ||o+=oB. o ||..E==*... |+-----------------+补充说明ssh-keygen:生成秘钥其中： -t指定算法 -f 指定生成秘钥路径 -N 指定密码 查看钥匙 1234[root@Server1 ~]# ls -l .ssh 总用量 8 -rw-------. 1 root root 1675 12月 10 22:20 id_rsa -rw-r--r--. 1 root root 394 12月 10 22:20 id_rsa.pub 将公钥复制到被管理机器Server2和Server3下的.ssh目录下（先确保存在这个目录） 1234567891011121314[root@server1 .ssh]# scp id_rsa.pub root@192.168.1.3:~/.ssh/ The authenticity of host '192.168.1.3(192.168.1.3)' can't be established. RSA key fingerprint is93:eb:f9:47:b1:f6:3f:b4:2e:21:c3:d5:ab:1d:ae:65. Are you sure you want to continueconnecting (yes/no)? yes Warning: Permanently added '192.168.1.3'(RSA) to the list of known hosts. root@192.168.1.3's password: id_rsa.pub [root@server1 .ssh]# scp id_rsa.pub root@192.168.1.4:~/.ssh/authorized_keys The authenticity of host '192.168.1.4(192.168.1.4)' can't be established. RSA key fingerprint is93:eb:f9:47:b1:f6:3f:b4:2e:21:c3:d5:ab:1d:ae:65. Are you sure you want to continueconnecting (yes/no)? yes Warning: Permanently added '192.168.1.4'(RSA) to the list of known hosts. root@192.168.1.4's password: id_rsa.pub 到Server2和Server3目录下执行下面的命令 1cat id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys 设置文件和目录权限： 1chmod 600 authorized_keys 验证使用SSH IP地址的方式无密码访问 1[root@server1 .ssh]# ssh 192.168.1.3 禁止密码登录修改SSH的配置文件/etc/ssh/sshd_config，找到下面1行：1PasswordAuthentication yes 修改为1PasswordAuthentication no 保存后重启SSH服务。1service sshd restart]]></content>
      <tags>
        <tag>linux</tag>
        <tag>ssh</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[expect交互编程]]></title>
    <url>%2Flinux%2Fexpect%2F</url>
    <content type="text"><![CDATA[安装12Ubuntu：apt-get install expectmac: brew install homebrew/dupes/expect 设置变量1set password rootddd 获取参数1set filename [lindex $argv 0] 一般格式 开头一定要是expect1234567891011121314#!/usr/bin/expectset filename [lindex $argv 0]set password example_pass# 开始执行命令spawn ssh root@example.com# 匹配（如果包含，则执行下面的send）expect &quot;password:&quot;# \r回车send &quot;$password\r&quot;send &quot;ls\r&quot;send &quot;exit\r&quot;# 结束标志interact]]></content>
      <tags>
        <tag>linux</tag>
        <tag>expect</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络管理]]></title>
    <url>%2Flinux%2F%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[netstat 查看端口状况 1netstat -apn 查看连接数 1234// 80端口netstat -nat|grep -i &quot;80&quot;|wc -l// 已连接上的netstat -na|grep ESTABLISHED|wc -l ufw(端口管理) 安装 1sudo apt-get install ufw 开启，默认关闭所有 12sudo ufw enable sudo ufw default deny 查看端口状态 1sudo ufw status 新增端口 1sudo ufw allow 8080 删除端口 1sudo ufw delete allow 8080 允许特定来源的访问 1sudo ufw allow from 192.168.1.1 ssh翻墙1234参考：[实战 SSH 端口转发](http://www.ibm.com/developerworks/cn/linux/l-cn-sshforward/)ssh -D &lt;local port&gt; &lt;SSH Server&gt;例：ssh -D 7000 root@xbug.site]]></content>
      <tags>
        <tag>linux</tag>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[参数]]></title>
    <url>%2Fhttp%2F%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[url传参 这种在各种method（get，post，delete，put）都能使用，解析速度快 body体中的参数application/x-www-form-urlencoded这应该是最常见的 POST 提交数据的方式了。浏览器的原生 表单，如果不设置 enctype 属性，那么最终就会以 application/x-www-form-urlencoded 方式提交数据。请求类似于下面这样（无关的请求头在本文中都省略掉了）：1234POST http://www.example.com HTTP/1.1Content-Type: application/x-www-form-urlencoded;charset=utf-8title=test&amp;sub%5B%5D=1&amp;sub%5B%5D=2&amp;sub%5B%5D=3 首先，Content-Type 被指定为 application/x-www-form-urlencoded；其次，提交的数据按照 key1=val1&amp;key2=val2 的方式进行编码，key 和 val 都进行了 URL 转码。大部分服务端语言都对这种方式有很好的支持。例如 PHP 中，$_POST[‘title’] 可以获取到 title 的值，$_POST[‘sub’] 可以得到 sub 数组。很多时候，我们用 Ajax 提交数据时，也是使用这种方式。例如 JQuery 和 QWrap 的 Ajax，Content-Type 默认值都是「application/x-www-form-urlencoded;charset=utf-8」。 multipart/form-data这又是一个常见的 POST 数据提交的方式。我们使用表单上传文件时，必须让 表单的 enctype 等于 multipart/form-data。直接来看一个请求示例：12345678910111213POST http://www.example.com HTTP/1.1Content-Type:multipart/form-data; boundary=----WebKitFormBoundaryrGKCBY7qhFd3TrwA------WebKitFormBoundaryrGKCBY7qhFd3TrwAContent-Disposition: form-data; name=&quot;text&quot;title------WebKitFormBoundaryrGKCBY7qhFd3TrwAContent-Disposition: form-data; name=&quot;file&quot;; filename=&quot;chrome.png&quot;Content-Type: image/pngPNG ... content of chrome.png ...------WebKitFormBoundaryrGKCBY7qhFd3TrwA-- 这个例子稍微复杂点。首先生成了一个 boundary 用于分割不同的字段，为了避免与正文内容重复，boundary 很长很复杂。然后 Content-Type 里指明了数据是以 multipart/form-data 来编码，本次请求的 boundary 是什么内容。消息主体里按照字段个数又分为多个结构类似的部分，每部分都是以 –boundary 开始，紧接着是内容描述信息，然后是回车，最后是字段具体内容（文本或二进制）。如果传输的是文件，还要包含文件名和文件类型信息。消息主体最后以 –boundary– 标示结束。关于 multipart/form-data 的详细定义，请前往 rfc1867 查看。这种方式一般用来上传文件，各大服务端语言对它也有着良好的支持。上面提到的这两种 POST 数据的方式，都是浏览器原生支持的，而且现阶段标准中原生 表单也只支持这两种方式（通过 元素的 enctype 属性指定，默认为 application/x-www-form-urlencoded。其实 enctype 还支持 text/plain，不过用得非常少）。随着越来越多的 Web 站点，尤其是 WebApp，全部使用 Ajax 进行数据交互之后，我们完全可以定义新的数据提交方式，给开发带来更多便利。 application/jsonapplication/json 这个 Content-Type 作为响应头大家肯定不陌生。实际上，现在越来越多的人把它作为请求头，用来告诉服务端消息主体是序列化后的 JSON 字符串。由于 JSON 规范的流行，除了低版本 IE 之外的各大浏览器都原生支持 JSON.stringify，服务端语言也都有处理 JSON 的函数，使用 JSON 不会遇上什么麻烦。JSON 格式支持比键值对复杂得多的结构化数据，这一点也很有用。记得我几年前做一个项目时，需要提交的数据层次非常深，我就是把数据 JSON 序列化之后来提交的。不过当时我是把 JSON 字符串作为 val，仍然放在键值对里，以 x-www-form-urlencoded 方式提交。1234POST http://www.example.com HTTP/1.1 Content-Type: application/json;charset=utf-8&#123;"title":"test","sub":[1,2,3]&#125; 这种方案，可以方便的提交复杂的结构化数据，特别适合 RESTful 的接口。各大抓包工具如 Chrome 自带的开发者工具、Firebug、Fiddler，都会以树形结构展示 JSON 数据，非常友好。但也有些服务端语言还没有支持这种方式，例如 php 就无法通过 $_POST 对象从上面的请求中获得内容。这时候，需要自己动手处理下：在请求头中 Content-Type 为 application/json 时，从 php://input 里获得原始输入流，再 json_decode 成对象。一些 php 框架已经开始这么做了。 text/xml 本人对此格式有成见，就不赘述了。]]></content>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[进程-线程-协程]]></title>
    <url>%2Fhttp%2F%E5%B9%B6%E5%8F%91%2F</url>
    <content type="text"><![CDATA[进程-线程-协程简单描述 进程、线程和协程之间的关系和区别也困扰我一阵子了，最近有一些心得，写一下。 进程拥有自己独立的堆和栈，既不共享堆，亦不共享栈，进程由操作系统调度。 线程拥有自己独立的栈和共享的堆，共享堆，不共享栈，线程亦由操作系统调度(标准线程是的)。 协程和线程一样共享堆，不共享栈，协程由程序员在协程的代码里显示调度。 进程和其他两个的区别还是很明显的。 协程和线程的区别是：协程避免了无意义的调度，由此可以提高性能，但也因此，程序员必须自己承担调度的责任，同时，协程也失去了标准线程使用多CPU的能力。 打个比方吧，假设有一个操作系统，是单核的，系统上没有其他的程序需要运行，有两个线程 A 和 B ，A 和 B 在单独运行时都需要 10 秒来完成自己的任务，而且任务都是运算操作，A B 之间也没有竞争和共享数据的问题。现在 A B 两个线程并行，操作系统会不停的在 A B 两个线程之间切换，达到一种伪并行的效果，假设切换的频率是每秒一次，切换的成本是 0.1 秒(主要是栈切换)，总共需要 20 + 19 0.1 = 21.9 秒。如果使用协程的方式，可以先运行协程 A ，A 结束的时候让位给协程 B ，只发生一次切换，总时间是 20 + 1 0.1 = 20.1 秒。如果系统是双核的，而且线程是标准线程，那么 A B 两个线程就可以真并行，总时间只需要 10 秒，而协程的方案仍然需要 20.1 秒。 进程 进程的出现是为了更好的利用CPU资源使到并发成为可能。 假设有两个任务A和B，当A遇到IO操作，CPU默默的等待任务A读取完操作再去执行任务B，这样无疑是对CPU资源的极大的浪费。聪明的老大们就在想若在任务A读取数据时，让任务B执行，当任务A读取完数据后，再切换到任务A执行。注意关键字切换，自然是切换，那么这就涉及到了状态的保存，状态的恢复，加上任务A与任务B所需要的系统资源（内存，硬盘，键盘等等）是不一样的。自然而然的就需要有一个东西去记录任务A和任务B分别需要什么资源，怎样去识别任务A和任务B等等。登登登，进程就被发明出来了。通过进程来分配系统资源，标识任务。如何分配CPU去执行进程称之为调度，进程状态的记录，恢复，切换称之为上下文切换。进程是系统资源分配的最小单位，进程占用的资源有：地址空间，全局变量，文件描述符，各种硬件等等资源。 线程 线程的出现是为了降低上下文切换的消耗，提高系统的并发性，并突破一个进程只能干一样事的缺陷，使到进程内并发成为可能。假设，一个文本程序，需要接受键盘输入，将内容显示在屏幕上，还需要保存信息到硬盘中。若只有一个进程，势必造成同一时间只能干一样事的尴尬（当保存时，就不能通过键盘输入内容）。若有多个进程，每个进程负责一个任务，进程A负责接收键盘输入的任务，进程B负责将内容显示在屏幕上的任务，进程C负责保存内容到硬盘中的任务。这里进程A，B，C间的协作涉及到了进程通信问题，而且有共同都需要拥有的东西——-文本内容，不停的切换造成性能上的损失。若有一种机制，可以使任务A，B，C共享资源，这样上下文切换所需要保存和恢复的内容就少了，同时又可以减少通信所带来的性能损耗，那就好了。是的，这种机制就是线程。线程共享进程的大部分资源，并参与CPU的调度, 当然线程自己也是拥有自己的资源的，例如，栈，寄存器等等。 此时，进程同时也是线程的容器。线程也是有着自己的缺陷的，例如健壮性差，若一个线程挂掉了，整一个进程也挂掉了，这意味着其它线程也挂掉了，进程却没有这个问题，一个进程挂掉，另外的进程还是活着。 协程 协程通过在线程中实现调度，避免了陷入内核级别的上下文切换造成的性能损失，进而突破了线程在IO上的性能瓶颈。 当涉及到大规模的并发连接时，例如10K连接。以线程作为处理单元，系统调度的开销还是过大。当连接数很多 —&gt; 需要大量的线程来干活 —&gt; 可能大部分的线程处于ready状态 —&gt; 系统会不断地进行上下文切换。既然性能瓶颈在上下文切换，那解决思路也就有了，在线程中自己实现调度，不陷入内核级别的上下文切换。说明一下，在历史上协程比线程要出现得早，在1963年首次提出, 但没有流行开来。为什么没有流行，没有找到信服的资料，先挖个坑，以后那天了解后，再补上。 小结 进程，线程，协程不断突破，更高效的处理阻塞，不断地提高CPU的利用率。但是并不是说，线程就一定比进程快，而协程就一定不线程要快。具体还是要看应用场景。可以简单粗暴的把应用分为IO密集型应用以及CPU密集型应用。 多核CPU，CPU密集型应用 此时多线程的效率是最高的，多线程可以使到全部CPU核心满载，又避免了协程间切换造成性能损失。当CPU密集型任务时，CPU一直在利用着，切换反而会造成性能损失，即便协程上下文切换消耗最小，但也还是有消耗的。 多核CPU，IO密集型应用 此时采用多线程多协程效率最高，多线程可以使到全部CPU核心满载，而一个线程多协程，则更好的提高了CPU的利用率。 单核CPU，CPU密集型应用 单进程效率是最高，此时单个进程已经使到CPU满载了。 单核CPU，IO密集型应用 多协程，效率最高。例如，看了上面应该也是知道的了 并发与并行并行 并发就是指同一时刻有两个或两个以上的“工作单位”在同时执行，从硬件的角度上来看就是同一时刻有两条或两条以上的指令处于执行阶段。所以，多核是并行的前提，单线程永远无法达到并行状态。可以利用多线程和度进程到达并行状态。另外的，Python的多线程由于GIL的存在，对于Python来说无法通过多线程到达并行状态。 并发 对于并发的理解，要从两方面去理解， 并发设计 并发执行。先说并发设计，当说一个程序是并发的，更多的是指这个程序采取了并发设计。 并发设计的标准： 使多个操作可以在重叠的时间段内进行，这里的重点在于重叠的时间内， 重叠时间可以理解为一段时间内。例如：在时间1s秒内, 具有IO操作的task1和task2都完成，这就可以说是并发执行。所以呢，单线程也是可以做到并发运行的。当然啦，并行肯定是并发的。一个程序能否并发执行，取决于设计，也取决于部署方式。例如, 当给程序开一个线程（协程是不开的），它不可能是并发的，因为在重叠时间内根本就没有两个task在运行。当一个程序被设计成完成一个任务再去完成下一个任务的时候，即便部署是多线程多协程的也是无法达到并发运行的。 并行与并发的关系: 并发的设计使到并发执行成为可能，而并行是并发执行的其中一种模式。]]></content>
      <tags>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[header]]></title>
    <url>%2Fhttp%2Fheader%2F</url>
    <content type="text"><![CDATA[判断客户端编码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public static function get_os($agent = null) &#123; if (!$agent) $agent = $_SERVER['HTTP_USER_AGENT']; if (preg_match('/win/i', $agent) &amp;&amp; preg_match('/nt 6.0/i', $agent)) &#123; $os = 'Windows Vista'; &#125; else if (preg_match('/win/i', $agent) &amp;&amp; preg_match('/nt 6.1/i', $agent)) &#123; $os = 'Windows 7'; &#125; else if (preg_match('/win/i', $agent) &amp;&amp; preg_match('/nt 6.2/i', $agent)) &#123; $os = 'Windows 8'; &#125; else if (preg_match('/win/i', $agent) &amp;&amp; preg_match('/nt 10.0/i', $agent)) &#123; $os = 'Windows 10';# 添加win10判断 &#125; else if (preg_match('/win/i', $agent) &amp;&amp; preg_match('/nt 5.1/i', $agent)) &#123; $os = 'Windows XP'; &#125; else if (preg_match('/win/i', $agent) &amp;&amp; preg_match('/nt 5/i', $agent)) &#123; $os = 'Windows 2000'; &#125; else if (preg_match('/win/i', $agent) &amp;&amp; preg_match('/nt/i', $agent)) &#123; $os = 'Windows NT'; &#125; else if (preg_match('/win/i', $agent) &amp;&amp; preg_match('/32/i', $agent)) &#123; $os = 'Windows 32'; &#125; else if (preg_match('/linux/i', $agent)) &#123; $os = 'Linux'; &#125; else if (preg_match('/unix/i', $agent)) &#123; $os = 'Unix'; &#125; else if (preg_match('/sun/i', $agent) &amp;&amp; preg_match('/os/i', $agent)) &#123; $os = 'SunOS'; &#125; else if (preg_match('/ibm/i', $agent) &amp;&amp; preg_match('/os/i', $agent)) &#123; $os = 'IBM OS/2'; &#125; else if (preg_match('/Mac/i', $agent)) &#123; $os = 'Macintosh'; &#125; else if (preg_match('/PowerPC/i', $agent)) &#123; $os = 'PowerPC'; &#125; else if (preg_match('/AIX/i', $agent)) &#123; $os = 'AIX'; &#125; else if (preg_match('/HPUX/i', $agent)) &#123; $os = 'HPUX'; &#125; else if (preg_match('/NetBSD/i', $agent)) &#123; $os = 'NetBSD'; &#125; else if (preg_match('/BSD/i', $agent)) &#123; $os = 'BSD'; &#125; else if (preg_match('/OSF1/i', $agent)) &#123; $os = 'OSF1'; &#125; else if (preg_match('/IRIX/i', $agent)) &#123; $os = 'IRIX'; &#125; else if (preg_match('/FreeBSD/i', $agent)) &#123; $os = 'FreeBSD'; &#125; else if (preg_match('/teleport/i', $agent)) &#123; $os = 'teleport'; &#125; else if (preg_match('/flashget/i', $agent)) &#123; $os = 'flashget'; &#125; else if (preg_match('/webzip/i', $agent)) &#123; $os = 'webzip'; &#125; else if (preg_match('/offline/i', $agent)) &#123; $os = 'offline'; &#125; else &#123; $os = '未知操作系统'; &#125; return $os; &#125; 页面输出12345678910header('HTTP/1.1 200 OK'); // ok 正常访问header('HTTP/1.1 404 Not Found'); //通知浏览器 页面不存在header('HTTP/1.1 301 Moved Permanently'); //设置地址被永久的重定向 301header('Location: http://www.form1.cn/'); //跳转到一个新的地址header('Refresh: 10; url=http://www.form1.cn/'); //延迟转向 也就是隔几秒跳转header('X-Powered-By: PHP/6.0.0'); //修改 X-Powered-By信息header('Content-language: en'); //文档语言header('Content-Length: 1234'); //设置内容长度header('Last-Modified: '.gmdate('D, d M Y H:i:s', $time).' GMT'); //告诉浏览器最后一次修改时间header('HTTP/1.1 304 Not Modified'); //告诉浏览器文档内容没有发生改变 内容输出123456789101112header('Content-Type: text/html; charset=utf-8'); //网页编码 header('Content-Type: text/plain'); //纯文本格式 header('Content-Type: image/jpeg'); //JPG、JPEG header('Content-Type: application/zip'); // ZIP文件 header('Content-Type: application/pdf'); // PDF文件 header('Content-Type: audio/mpeg'); // 音频文件 header('Content-type: text/css'); //css文件header('Content-type: text/javascript'); //js文件header('Content-type: application/json'); //jsonheader('Content-type: application/pdf'); //pdf header('Content-type: text/xml'); //xmlheader('Content-Type: application/x-shockw**e-flash'); //Flash动画 声明一个下载文件1234header('Content-Type: application/octet-stream'); header('Content-Disposition: attachment; filename="ITblog.zip"'); header('Content-Transfer-Encoding: binary'); readfile('test.zip'); 对当前文档禁用缓存12header('Cache-Control: no-cache, no-store, max-age=0, must-revalidate'); header('Expires: Mon, 26 Jul 1997 05:00:00 GMT'); 身份认证12header('HTTP/1.1 401 Unauthorized'); header('WWW-Authenticate: Basic realm="Top Secret"'); 声明一个需要下载的xls文件1234567header('Content-Disposition: attachment; filename=ithhc.xlsx');header('Content-Type: application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');header('Content-Length: '.filesize('./test.xls')); header('Content-Transfer-Encoding: binary'); header('Cache-Control: must-revalidate'); header('Pragma: public'); readfile('./test.xls'); download12345678910header("Content-type: application/force-download");// 判断编码$use_utf_8 = Utils::get_os() == 'Macintosh';if (!$use_utf_8) &#123; // Disposition中文是处置的意思, 可以理解为文档如何处置 header("Content-Disposition: attachment;filename=" . iconv("utf-8", "gb2312//IGNORE", $zip_title) . ".zip");&#125; else &#123; header("Content-Disposition: attachment;filename=" . $zip_title . ".zip");&#125;echo file_get_contents($zip_path);]]></content>
      <tags>
        <tag>http</tag>
        <tag>header</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cors(跨域)]]></title>
    <url>%2Fhttp%2F%E8%B7%A8%E5%9F%9Fcors%2F</url>
    <content type="text"><![CDATA[摘自阮老师CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing） 两种请求浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。只要同时满足以下两大条件，就属于简单请求。 请求方法是以下三种方法之一： 123HEADGETPOST HTTP的头信息不超出以下几种字段： 12345AcceptAccept-LanguageContent-LanguageLast-Event-IDContent-Type：只限于三个值application/x-www-form-urlencoded、multipart/form-data、text/plain 简单请求对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个Origin字段。例如：123456GET /cors HTTP/1.1Origin: http://api.bob.comHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... 不同意如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应(虽然是拒绝的回应)。浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。 同意如果Origin指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。1234Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Credentials: trueAccess-Control-Expose-Headers: FooBarContent-Type: text/html; charset=utf-8 Access-Control-Allow-Origin该字段是必须的。它的值要么是请求时Origin字段的值，要么是一个*，表示接受任意域名的请求。 Access-Control-Allow-Credentials该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为true，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为true，如果服务器不要浏览器发送Cookie，删除该字段即可。 Access-Control-Expose-Headers该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。上面的例子指定，getResponseHeader(‘FooBar’)可以返回FooBar字段的值。 withCredentials 属性上面说到，CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定Access-Control-Allow-Credentials字段。1Access-Control-Allow-Credentials: true 另一方面，开发者必须在AJAX请求中打开withCredentials属性。12var xhr = new XMLHttpRequest();xhr.withCredentials = true; 否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。但是，如果省略withCredentials设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭withCredentials1xhr.withCredentials = false; 需要注意的是，如果要发送Cookie，Access-Control-Allow-Origin就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的document.cookie也无法读取服务器域名下的Cookie。 非简单请求预检请求非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为”预检”请求（preflight）。浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。下面是一段浏览器的JavaScript脚本。12345var url = 'http://api.alice.com/cors';var xhr = new XMLHttpRequest();xhr.open('PUT', url, true);xhr.setRequestHeader('X-Custom-Header', 'value');xhr.send(); 浏览器发现，这是一个非简单请求，就自动发出一个”预检”请求，要求服务器确认可以这样请求。下面是这个”预检”请求的HTTP头信息。12345678OPTIONS /cors HTTP/1.1Origin: http://api.bob.comAccess-Control-Request-Method: PUTAccess-Control-Request-Headers: X-Custom-HeaderHost: api.alice.comAccept-Language: en-USConnection: keep-aliveUser-Agent: Mozilla/5.0... 关键字段是Origin“预检”请求用的请求方法是OPTIONS，表示这个请求是用来询问的。头信息里面，关键字段是Origin，表示请求来自哪个源。 除了Origin字段，”预检”请求的头信息包括两个特殊字段。（1）Access-Control-Request-Method该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是PUT。（2）Access-Control-Request-Headers该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是X-Custom-Header。 预检请求的回应服务器收到”预检”请求以后，检查了Origin、Access-Control-Request-Method和Access-Control-Request-Headers字段以后，确认允许跨源请求，就可以做出回应。123456789101112HTTP/1.1 200 OKDate: Mon, 01 Dec 2008 01:15:39 GMTServer: Apache/2.0.61 (Unix)Access-Control-Allow-Origin: http://api.bob.comAccess-Control-Allow-Methods: GET, POST, PUTAccess-Control-Allow-Headers: X-Custom-HeaderContent-Type: text/html; charset=utf-8Content-Encoding: gzipContent-Length: 0Keep-Alive: timeout=2, max=100Connection: Keep-AliveContent-Type: text/plain Access-Control-Allow-Methods该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。 Access-Control-Allow-Headers如果浏览器请求包括Access-Control-Request-Headers字段，则Access-Control-Allow-Headers字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在”预检”中请求的字段。 Access-Control-Allow-Credentials该字段与简单请求时的含义相同。 Access-Control-Max-Age该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。 go-gin cors设置1234567router = gin.Default()config := cors.DefaultConfig()config.AllowAllOrigins = trueconfig.AllowMethods = []string&#123;&quot;GET&quot;, &quot;POST&quot;, &quot;OPTIONS&quot;&#125;config.AllowHeaders = []string&#123;&quot;DNT&quot;, &quot;X-Mx-ReqToken&quot;, &quot;Keep-Alive&quot;, &quot;User-Agent&quot;, &quot;X-Requested-With&quot;, &quot;If-Modified-Since&quot;, &quot;Cache-Control&quot;, &quot;Content-Type&quot;, &quot;Authorization&quot;, &quot;X-Token&quot;&#125;router.Use(cors.New(config))]]></content>
      <tags>
        <tag>http</tag>
        <tag>cors</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cookie]]></title>
    <url>%2Fhttp%2Fcookie%2F</url>
    <content type="text"><![CDATA[cookie 是怎么工作的当网页要发http请求时，浏览器会先检查是否有相应的cookie，有则自动添加在request header中的cookie字段中。这些是浏览器自动帮我们做的，而且每一次http请求浏览器都会自动帮我们做。这个特点很重要，因为这关系到“什么样的数据适合存储在cookie中”。 存储在cookie中的数据，每次都会被浏览器自动放在http请求中，如果这些数据并不是每个请求都需要发给服务端的数据，浏览器这设置自动处理无疑增加了网络开销；但如果这些数据是每个请求都需要发给服务端的数据（比如身份认证信息），浏览器这设置自动处理就大大免去了重复添加操作。所以对于那设置“每次请求都要携带的信息（最典型的就是身份认证信息）”就特别适合放在cookie中，其他大多数类型的数据就不适合了。 cookie 属性每个cookie都有一定的属性，如什么时候失效，要发送到哪个域名，哪个路径等等。这些属性是通过cookie选项来设置的，cookie选项包括：expires、domain、path、secure、HttpOnly。在设置任一个cookie时都可以设置相关的这些属性，当然也可以不设置，这时会使用这些属性的默认值。在设置这些属性时，属性之间由一个分号和一个空格隔开。代码示例如下：1"key=name; expires=Thu, 25 Feb 2016 04:18:00 GMT; domain=ppsc.sankuai.com; path=/; secure; HttpOnly" expiresexpires选项用来设置“cookie 什么时间内有效”。expires其实是cookie失效日期，expires必须是 GMT 格式的时间（可以通过 new Date().toGMTString()或者 new Date().toUTCString() 来获得）。 expires 是 http/1.0协议中的选项，在新的http/1.1协议中expires已经由 max-age 选项代替，两者的作用都是限制cookie 的有效时间。expires的值是一个时间点（cookie失效时刻= expires），而max-age 的值是一个以秒为单位时间段（cookie失效时刻= 创建时刻+ max-age）。另外，max-age 的默认值是 -1(即有效期为 session )；若max-age有三种可能值：负数、0、正数。负数：有效期session；0：删除cookie；正数：有效期为创建时刻+ max-age domain 和 pathdomain是域名，path是路径，两者加起来就构成了 URL，domain和path一起来限制 cookie 能被哪些 URL 访问。一句话概括：某cookie的 domain为“baidu.com”, path为“/ ”，若请求的URL(URL 可以是js/html/img/css资源请求，但不包括 XHR 请求)的域名是“baidu.com”或其子域如“api.baidu.com”、“dev.api.baidu.com”，且 URL 的路径是“/ ”或子路径“/home”、“/home/login”，则浏览器会将此 cookie 添加到该请求的 cookie 头部中。发生跨域xhr请求时，即使请求URL的域名和路径都满足 cookie 的 domain 和 path，默认情况下cookie也不会自动被添加到请求头部中 securesecure选项用来设置cookie只在确保安全的请求中才会发送。当请求是HTTPS或者其他安全协议时，包含 secure 选项的 cookie 才能被发送至服务器。默认情况下，cookie不会带secure选项(即为空)。所以默认情况下，不管是HTTPS协议还是HTTP协议的请求，cookie 都会被发送至服务端 httpOnly这个选项用来设置cookie是否能通过 js 去访问。默认情况下，cookie不会带httpOnly选项(即为空)，所以默认情况下，客户端是可以通过js代码去访问（包括读取、修改、删除等）这个cookie的。当cookie带httpOnly选项时，客户端则无法通过js代码去访问（包括读取、修改、删除等）这个cookie。 如何设置cookie服务端设置 cookie不管你是请求一个资源文件（如 html/js/css/图片），还是发送一个ajax请求，服务端都会返回response。而response header中有一项叫set-cookie，是服务端专门用来设置cookie的。一个set-Cookie字段只能设置一个cookie，当你要想设置多个 cookie，需要添加同样多的set-Cookie字段。服务端可以设置cookie 的所有选项：expires、domain、path、secure、HttpOnly 客户端设置cookie客户端可以设置cookie 的下列选项：expires、domain、path、secure（有条件：只有在https协议的网页中，客户端设置secure类型的 cookie 才能成功），但无法设置HttpOnly选项。]]></content>
      <tags>
        <tag>http</tag>
        <tag>cookie</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongoIndex]]></title>
    <url>%2Fmongodb%2FIndex%2F</url>
    <content type="text"><![CDATA[查看索引123&gt; db.user.getIndexSpecs() or&gt; db.user.getIndexes() id索引默认创建 _id 单键索引 创建索引：1db.user.createIndex(&#123;x:1&#125;) 索引可以重复创建，如果索引已存在，则直接返回成功 复合索引1db.user.createIndex(&#123;x:1,y:1&#125;) 过期索引1db.user.createIndex(&#123;"expiredAt":1&#125;, &#123;expireAfterSeconds: 604800, background: true&#125;) 唯一索引1db.user.createIndex(&#123;"uid":1, "aid":1&#125;, &#123;"unique" : true, background: true&#125;) 查看索引创建进度12345678db.currentOp( &#123; $or: [ &#123; op: "command", "query.createIndexes": &#123; $exists: true &#125; &#125;, &#123; op: "insert", ns: /\.system\.indexes\b/ &#125; ] &#125;) 终止索引的创建1db.killOp() 查看索引1234567891011121314151617181920212223242526272829&gt; db.user.getIndexes()[ &#123; "v" : 2, "key" : &#123; "_id" : 1 &#125;, "name" : "_id_", "ns" : "blog.user" &#125;, &#123; "v" : 2, "key" : &#123; "x" : 1 &#125;, "name" : "x_1", "ns" : "blog.user" &#125;, &#123; "v" : 2, "key" : &#123; "x" : 1, "y" : 1 &#125;, "name" : "x_1_y_1", "ns" : "blog.user" &#125;]&gt;]]></content>
      <tags>
        <tag>mongo</tag>
        <tag>index</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[导入导出]]></title>
    <url>%2Fmongodb%2F%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA%2F</url>
    <content type="text"><![CDATA[拿阿里云MongoDB举例 Keys：mongoexport，mongoimport 导出：示例： 1234567891011121314151617mongoexport -h dds-********.mongodb.rds.aliyuncs.com:3717 --authenticationDatabase admin -u root -p **** -d ranger -c players -o players.json -q '&#123;id: &#123;"$in": [16398, 10001]&#125;&#125;'mongoexport -h dds-********.mongodb.rds.aliyuncs.com:3717 --authenticationDatabase admin -u root -p **** -d pigcome -c dollOrders -o orders.csv -q '&#123;orderId: &#123;"$gte": 1&#125;&#125;' --type csv -f uid,orderId,dollId,name,weChat,phone,address,mark,statusmongoexport -h 10.10.100.100:27017 --authenticationDatabase admin -u mongouser -p ******** -d **** -c robots -o robot.json参数说明：-h MongoDB服务器地址--authenticationDatabase 验证角色数据库-u 登录帐号-p 登录密码-d 连接数据库-c 默认集合-o 导出文件名-q 查询语句-type 导出类型-f 导出字段 导入：示例： 123456789mongoimport -h dds-m5e7bc768a732d041.mongodb.rds.aliyuncs.com:3717 --authenticationDatabase admin -u root -p ******** -d ranger -c players players.json参数说明：-h MongoDB服务器地址--authenticationDatabase 验证角色数据库-u 登录帐号-p 登录密码-d 连接数据库-c 默认集合]]></content>
      <tags>
        <tag>mongo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[论成熟的男银]]></title>
    <url>%2Fdigest%2F%E8%AE%BA%E6%88%90%E7%86%9F%E7%9A%84%E7%94%B7%E9%93%B6%2F</url>
    <content type="text"><![CDATA[摘自知乎：吴遇安 能够解决问题的男人就是成熟的男人这个题目看似很容易写，因为每个人都可以有自己对于“成熟”的理解，但答主更崇尚用较为理性的方式来分析这个命题，所以下面，我会尽可能用一种严谨的方式来解构这个命题。 我们列出了某个界定标准，符合这个标准的，便是“成熟男人”，而这个问题便是在探讨这个标准是什么，其实这个问题下的许多回答中提出的标准，反例都太好举了，一个挖鼻孔的大色狼坂田银时，恐怕难以符合这里的大多数标准，但是难道有人认为他“不成熟”吗？ 再举一个著名的范例君子君子XXX君子应该XXX君子不应该XXXXXX样的人才能算君子 类似的叙述，占据了我国古代儒家著述的很大一部分，很熟悉吧？古人讨论君子的时候，其实和我们现在讨论成熟男人的情形是一样的，大家都在纷纷说，梨子是水果，苹果是水果，却没能很好的给水果做一个足够精确的描述。本楼中的回答，男人们的大部分都在描述一个想象中的完美人格，甚至是想象中的自己（如同古人想象“君子”）而女孩子们的回答，则大多都在描述自己理想中的爱人形象。 须知，这个家伙出现在现实生活中的时候，许多女孩子也会觉得他是成熟男人呢。用这样的枚举法得到的结论，我认为并不具有很强的说服力。因此，我在这份回答里，就是希望探讨一条具有普适效用的标准，以此来界定成熟男人的边界。 我们在生活中普遍认同的成熟男人形象，包含了许多的要素，冷静，善良，宽容，等等等等，那么，到底其中的哪些，才是造成“成熟男人”与“不成熟男人”的根本分界点呢，成熟男人的定义，对于实践有什么指导意义？ 我以前刷知乎的时候看过一个问题，问“为什么鸡汤文受人讨厌”，下面排名第一的回答叫做“因为没给勺子”。这其实就是本楼中许多答案的问题，只给了一个目标，“做到XX样就是成熟男人”，但是，为什么这样就是成熟男人，怎样才能成为成熟男人，对于这两个关键的问题，却没有进行解答，就是典型的“送汤不送勺”。而本文，则致力于解析“成熟”的本质，并且给出到达彼岸的路径。 我得到的答案是： 成熟与不成熟的根本分界点，在于“对于规律的理解和运用能力” 在对于成熟进行解析之前，我们首先要解决的，是这个问题。成熟的目的是什么？ 不要忽视这一点，成熟往往出现在两种语境之中，一曰”XX性格成熟“，二曰”XX处理某项事务的手法成熟‘，为什么我们追求成熟？因为在我们的想象和实践中，越”成熟（包括性格和处理手法）“，往往代表了对问题更强的解决能力 不论这个问题是追求更高的社会地位，更多的财富，更好的处理与他人的关系，更愉悦的生活和心态，或者是与这个世界更和谐地相处。以题目的题主为例，他感慨自己不成熟，其实是在感慨“处理两性关系的能力不强”！ 我们说，在某个领域内，张三比李四更成熟，指的是在该领域内，张三比李四有更强的解决问题的能力，而我们说张三比李四的性格更成熟，指的是张三在多个领域内均具有比李四更强的解决问题的能力。 在明了成熟的目的之后，我们接下来研究的，就是，在成熟包含的许多特质之中，有哪些对于达成这个目的具有最关键的影响，那么，这个（或者这些）特质就可以被认定为是决定某人“成熟度”的核心，是区分成熟与幼稚的根本分界点。 我们之前探讨的“成熟”，大多是出自对于一个完美人格的想象，这个完美的人格中包涵了许多要素，沉稳，冷静，善良，宽厚，仁爱，温柔，坚强，慷慨，自立，目标明确胸有大志等等等等。那么，如何确定哪一项特质才是区分成熟与幼稚的根本分界点呢？下面，我来介绍一种我本人分析问题时的常用方法，即“去除噪声法”，分为四步 第一步，收集，收集所有我们对于“成熟”特质的想象，加以总结归纳。第二步，筛选，这许多的特质中，有哪些是“成熟”特有的，即“幼稚”的人几乎不可能具备的。第三步，对比，“成熟”的人特有的素质中，共性在于哪里。第四步，分析，“成熟”素质的共性，应当如何锻炼？ 第一步，收集稳重，善良，冷静，宽厚，目标明确，坚强，勇敢，自立，慷慨，礼貌，低调，智慧，果断，有责任感。统计了这个楼里的三百多个答案，归纳出的特质大致如此，这些素质，如果一个男人具备了，毫无疑问他是成熟的，一个女人要想找到这样的男人，做梦也要笑醒。 第二步，筛选。在诸多特质中，有一些是“幼稚”的男人也能够拥有的，有一些是并非是“成熟男人”必备的，（例如坂田银时不礼貌，古美门律师。。。算了我不说了。。半泽直树君爱记仇，但是我们也普遍认为这几位都是成熟男人），这些特质，我将在下面列出并加以剔除。善良，幼稚男也可以有，pass 坚强，pass 礼貌，pass 有责任感，pass 勇敢，pass 宽厚，pass慷慨，pass那么剩下的有 稳重 冷静 目标明确 自立 低调 智慧 果断稳重，代表考虑问题全面的能力冷静，代表处变不惊的能力目标明确，低调和自立三种特质可以合并，为图方便，下面均以“自立”代替三者，代表不以物喜，不以己悲，内心抗击外界干扰的能力，清楚自己的需求，并且坚定不移地加以追求智慧，稳重代表考虑问题全面，而智慧则又多了一种素质，能够抓住问题的关键点，果断，代表面临选择时的决断能力。 第三步，找出共性第二步中提到，这五项素质，是成熟男人必备，也是成熟男人特有的能力，在这个步骤之中，我将解析，这五种素质的核心共性是什么。换句话来说，你做到了某件事情，就能够自然而然的拥有这五种特质，我的任务就是解析出“这件事情”是什么。 如果把团队中的工作分为”智“与”力“（可理解为思考和执行），那么我的属性就是”智“。我曾经不止一次的思考过，“智”与“力”的极限在哪里，“力”的极限，可描述为“专拆南墙”，就像成语故事里无坚不摧的矛，没有捅不穿的防御。而“智”的极限，我认为，是“预知”。对于智者而言，学习和实践都是为了找寻事物发展变化的规律，而找寻规律，则是为了推测日后事物的形态。因此，“智”的极限，即是“预知”。 稳重，冷静，目标明确，智慧，果断。这五种素质都有一个共性，即它们的主人，已经“知道”了。曾经经历过，知道接下来会发生什么，并且对可能出现出现的几种结果都做好了准备。因为他已经“知道”了，所以，自然能够全面的考虑问题因为已经经历过了，所以不会惊慌失措，从而能够处变不惊因为“知道了”，所以能够准确的找出问题的核心因为已经对于各种结果都做好了应对的准备，或者说能够接受失败，所以成熟男人才能果断地下决定成熟男人的目标很明确，不会被外物所扰，因为他已经“经历过”，并且“知道了”。所以，这五种素质的核心，即在于“经历”，和“知道”。 从实践和理论中领悟出规律，并且能够在实践中运用规律，从而获得强大的解决问题的能力，即为成熟。 成熟区别于幼稚的的核心，即，对于“规律”的理解和运用。 最后，是第四步，应当如何锻炼。多实践，多读书，多思考。不是烂尾，而是我实在找不到比这九个字更好的词来描述了。主动地去经历事物，积极地从书中和自己的实践中总结规律，思考如何应用规律，就是达到“成熟”彼岸的通道。 成熟”从本质上来说，是一种技能而非性格，性格的养成来源于技能的提升。我们从小到大被说了那么多年的不成熟，究竟传说中的成熟是什么东西？ 成熟绝不只是停留于高僧，老头子，中年大叔身上的专利，我们更没有必要将之神化，“鸡汤化”，成熟不是性格，只是一种技能，古美门律师在处理案件的时候手法非常成熟，对自己作为律师的“道”达到了坚信不疑的程度，不可不谓之境界高深，但是在处理人际关系的时候态度却不成熟，暴躁，没礼貌，不稳重。银他妈经历了丰富的人生，面对危局处事不惊，战场上白夜叉几度血战来回，却连区区甜食的诱惑也抵挡不了。他们都成熟，他们也都不成熟。 维特根斯坦说过，说不出来的东西就当它不存在，我认为包括成熟男人在内，好多我们日常的概念都被过分神化了，明明是可以解析的事情，搞得神神叨叨，令人甚为不爽对我们这些不完美的人来说，要求一个人“成熟”起来，并非要求他“能够解决一切事情”，而是要求他“在总体解决问题的能力上达到他这个年纪的人的均值”。何必急于一时？何必用完美的标准去要求所有人？ 对于我们少年人来说，这几个家伙何尝不是成熟？ 我是要成为海贼王的男人，就算为此而死，也无所谓 ———Monkey D Luffy 因为我是天才 ———樱木花道为什么你这么不成熟？因为我是天才啊哈哈哈]]></content>
      <tags>
        <tag>有趣的灵魂</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mgo]]></title>
    <url>%2Fgolang%2Fmgo%2F</url>
    <content type="text"><![CDATA[mongodb客户端的golang实现mgo很有可能作为golang的标准库mgo文档 连接123456789101112131415161718192021222324252627282930313233package databaseimport ( "full_text_search/config" "gopkg.in/mgo.v2")var Session *mgo.Session// 简单实现单例，只创建一个sessionfunc init() &#123; if Session == nil &#123; var err error Session, err = mgo.Dial(config.MongoDB.Host + ":" + config.MongoDB.Port) if err != nil &#123; panic("连接mongodb失败，原因：" + err.Error()) &#125; &#125;&#125;func Collection(collectionName string, f func(collection *mgo.Collection)) (err error) &#123; // mgo内部实现了连接池，通过clone获取连接 session := Session.Clone() defer func() &#123; session.Close() if err := recover(); err != nil &#123; return &#125; &#125;() collection := session.DB(config.MongoDB.Database).C(collectionName) f(collection) return&#125; 登录12345678Session, err = mgo.Dial(config.MongoDB.Host + ":" + config.MongoDB.Port)if err != nil &#123; panic("连接mongodb失败，原因：" + err.Error())&#125;err = Session.DB("admin").Login(config.MongoDB.User, config.MongoDB.Password)if err != nil&#123; panic("登录mongodb失败，原因：" + err.Error())&#125; 增删改查上述是建立连接，并执行操作 insert1234567891011121314151617type d struct &#123; X int Y int Z int&#125;database.Collection("user", func(collection *mgo.Collection) &#123; var insertDatas = []interface&#123;&#125;&#123; d&#123;6, 6, 6&#125;, d&#123;7, 6, 6&#125;, d&#123;8, 6, 6&#125;, &#125; var insertData = d&#123;9, 9, 9&#125; //插入单条 collection.Insert(insertData) //插入多条 collection.Insert(insertDatas...)&#125;) select123456789101112131415161718192021type d struct &#123; X int Y int Z int&#125;// 为了代码的可读性，没有验证错误errordatabase.Collection("user", func(collection *mgo.Collection) &#123; var resDatas []d var resData d query := collection.Find(bson.M&#123;"x": 1&#125;) //统计数目 count, _ := query.Count() //链式操作，类似函数式编程 query = query.Sort("y").Skip(1).Limit(2) //查询所有 query.All(&amp;resDatas) //查询第一个 query.One(&amp;resData) fmt.Println(resDatas, resData, count)&#125;) delete1234// 为了代码的可读性，没有验证错误errordatabase.Collection("user", func(collection *mgo.Collection) &#123; collection.Remove(bson.M&#123;"x": 1&#125;)&#125;) update 修改第一条，修改此条全部内容 123456//struct 的键需要大写collection.Update(bson.M&#123;"x": 3&#125;, struct &#123; X int Y int Z int&#125;&#123;3, 4, 5&#125;) 修改第一条，修改此条部分内容 1collection.Update(bson.M&#123;"x": 0&#125;, bson.M&#123;"$set": bson.M&#123;"y": 1&#125;&#125;) 修改多条，只能修改每一条的部分内容 1234567891011121314changeLog, err := collection.UpdateAll(bson.M&#123;"x": 6&#125;, bson.M&#123;"$set": bson.M&#123;"y": 1&#125;&#125;)if err != nil &#123; fmt.Println(err.Error())&#125;fmt.Println("Matched:", changeLog.Matched)fmt.Println("Removed:", changeLog.Removed)fmt.Println("Updated:", changeLog.Updated)fmt.Println("UpsertedId:", changeLog.UpsertedId)// 结果&gt; go run test.goMatched: 2Removed: 0Updated: 2UpsertedId: &lt;nil&gt;]]></content>
      <tags>
        <tag>go</tag>
        <tag>mongo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反射]]></title>
    <url>%2Fgolang%2F%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[详见：go标准包：reflect 特点 大大提高程序的灵活性，特别是与interface结合能够发挥更大的效果 反射使用TypeOf和ValueOf函数从接口中获取目标对象信息 反射会将匿名字段设为独立字段（匿名字段本质） 想要利用反射修改对象信息，前提是interface.data是settble,即pointer-interface 通过反射可以动态的调用方法 demo实例12345678910111213141516171819202122232425262728293031323334353637type User struct &#123; Id int Name string Age int&#125;func (u User) Hello() &#123; fmt.Println("hello world")&#125;func main() &#123; u := User&#123;12, "zhangsan", 33&#125; // 此处不可以传指针 Info(u)&#125;func Info(o interface&#123;&#125;) &#123; t := reflect.TypeOf(o) fmt.Println("Type:", t.Name()) v := reflect.ValueOf(o) fmt.Println("Field:") if k := t.Kind(); k != reflect.Struct &#123; fmt.Println("不是interface的struct类型") return &#125; for i := 0; i &lt; t.NumField(); i++ &#123; f := t.Field(i) val := v.Field(i).Interface() fmt.Println(f.Name,f.Type,f.Anonymous,val) &#125;&#125;//结果：➜ first go run helloworld.goType: UserField:Id int false 12Name string false zhangsanAge int false 33 匿名字段的反射1234567891011121314151617181920212223242526type User struct &#123; Id int Name string Age int&#125;type Manage struct &#123; User Title string&#125;func main() &#123; m := Manage&#123;User&#123;12, "zhangsan", 14&#125;, "wangwu"&#125; t := reflect.TypeOf(m) // 匿名字段的反射 fmt.Println(t.Field(1)) // 取出匿名字段的值 fmt.Println(t.FieldByIndex([]int&#123;0, 0&#125;)) // 取出正常字段的值 fmt.Println(t.FieldByIndex([]int&#123;1&#125;))&#125;// 结果：➜ first go run helloworld.go&#123;Title string 32 [1] false&#125;&#123;Id int 0 [0] false&#125;&#123;Title string 32 [1] false&#125; 通过反射改变其值 demo112345x := 13v := reflect.ValueOf(&amp;x)v.Elem().SetInt(999)fmt.Println(x)// 结果：999 demo212345678910111213141516171819202122232425262728293031323334type User struct &#123; Name string Age int sex int&#125;func main() &#123; u := User&#123;"zhansan", 12, 2&#125; f := reflect.ValueOf(&amp;u) v := reflect.ValueOf(u) // kind方法返回类型, // interface方法返回v当前持有的值（表示为/保管在interface&#123;&#125;类型）， // 等价于：var i interface&#123;&#125; = (v's underlying value) fmt.Println(v.Kind(), v.Type(), v.Interface()) if f.Kind() == reflect.Ptr &amp;&amp; !f.Elem().CanSet() &#123; fmt.Println("User不能被设置") return &#125;else&#123; // Elem返回v持有的接口保管的值的Value封装，或者v持有的指针指向的值的Value封装。 f = f.Elem() &#125; val := f.FieldByName("Name") // IsValid返回v是否持有一个值。如果v是Value零值会返回假，此时v除了IsValid、String、Kind之外的方法都会导致panic。 // 绝大多数函数和方法都永远不返回Value零值。如果某个函数/方法返回了非法的Value，它的文档必须显式的说明具体情况。 if (!val.IsValid()) &#123; fmt.Println("val不是有效值") return &#125; if (val.Kind() == reflect.String) &#123; // 设置值 val.SetString("wangwu") &#125; fmt.Println(u)&#125; 通过反射调用其方法123456789101112131415161718192021type User struct &#123; Name string Age int sex int&#125;func main() &#123; user := User&#123;"zhangsan", 12, 2&#125; f := reflect.ValueOf(user) // 返回v的名为name的方法的已绑定（到v的持有值的）状态的函数形式的Value封装。 mv := f.MethodByName("GetName") // slice格式,reflect.Value为一种reflect的value类型,包含reflect.Int... // ValueOf返回一个初始化为i接口保管的具体值的Value args := []reflect.Value&#123;reflect.ValueOf("wangwu")&#125; // func (v Value) Call(in []Value) []Value // Call方法使用输入的参数in调用v持有的函数。 mv.Call(args)&#125;func (user User) GetName(name string) &#123; fmt.Println("hello " + name + " my name is " + user.Name)&#125;]]></content>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读取配置文件]]></title>
    <url>%2Fgolang%2F%E8%AF%BB%E5%8F%96%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[使用json格式12345678910111213141516171819202122232425262728293031package configimport ( "io/ioutil" "encoding/json" "fmt" "log")type mysql struct &#123; Host string Port int&#125;var Data mysqlfunc init() &#123; // 判断是为了实现单例的效果 if Data.Port == 0 &#123; // 当前目录应该为main.go的目录 str, err := ioutil.ReadFile("./config/database.json") if err != nil &#123; fmt.Println("err: 读取json配置失败" + err.Error()) &#125; if err = json.Unmarshal(str, &amp;Data); err != nil &#123; fmt.Println("err: 解析json配置失败" + err.Error()) &#125; log.Println("读取配置文件成功") &#125; log.Println("执行init函数 配置文件")&#125;]]></content>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[发邮件]]></title>
    <url>%2Fgolang%2F%E5%8F%91%E9%82%AE%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[邮件的一般格式123456From:chimps@example.comTo:to@163.comSubject:TEST EMAILContent-Type: text/html; chatset=UTF-8&lt;h1&gt;hello go&lt;/h1&gt; 使用阿里云企业邮注意事项如果你的域名为example.com在阿里的域名那里都配好之后，发邮件的配置应该如下：1234HOST: smtp.example.comHOST_ADDR: smtp.example.com:25USER: 该企业邮箱所创建的子邮箱PASSWORD：user的password 代码：主要是使用net/smtp包的SendMail方法1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package mainimport ( "fmt" "net/smtp" "strings")const ( HOST = "smtp.example.com" ADDR = "smtp.example.com:25" USER = "chimps@example.com" PASSWORD = "xxx")func main() &#123; to := "to1@163.com;to1@163.com" subject := "TEST EMAIL" email_type := "html" message := "&lt;h1&gt;hello go&lt;/h1&gt;" if err := SendEmail(to, subject, email_type, message); err != nil &#123; fmt.Println("发送失败, reason:" + err.Error()) &#125;&#125;func SendEmail(to string, subject string, email_type string, message string) (err error) &#123; var content_type string switch email_type &#123; case "html": content_type = "Content-Type: text/html; chatset=UTF-8" case "text": content_type = "Content-Type: text/plain; chatset=UTF-8" &#125; auth := smtp.PlainAuth("", USER, PASSWORD, HOST) send_to := strings.Split(to, ";") for _, v := range send_to &#123; var msg []string msg = append(msg, "From:"+USER, "To:"+v, "Subject:"+subject, content_type, "\r\n"+message) msg_string := strings.Join(msg, "\r\n") fmt.Println(msg_string) if err = smtp.SendMail(ADDR, auth, USER, []string&#123;v&#125;, []byte(msg_string)); err != nil &#123; fmt.Println("send fail , reason: " + err.Error()) return &#125; else &#123; fmt.Println("send ok :" + v) &#125; &#125; return&#125; 改进一般情况下，发邮件时间比较耗时的事情，一般走异步处理]]></content>
      <tags>
        <tag>go</tag>
        <tag>mail</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数组与切片]]></title>
    <url>%2Fgolang%2F%E6%95%B0%E7%BB%84%E4%B8%8E%E5%88%87%E7%89%87%2F</url>
    <content type="text"><![CDATA[数组12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 索引数组a := [10]int&#123;2:20&#125;// 不指定数组长度a := [...]int&#123;1,2,3,4&#125;// 多维数组,只有第一维可以使用...a := [...][3]int&#123; &#123;1,2,3&#125;, &#123;2,3,4&#125;&#125;a := [2][3]int&#123; &#123;1,2,3&#125;, &#123;2,3,4&#125;&#125;//指针数组x,y := 1,2a := [...]*int&#123;&amp;x, &amp;y&#125;//指向数组的指针a :=[...]int&#123;99:1&#125;var p *[100]int = &amp;a// 数组之间可以使用 == 或 != 比较,只有长度和类型相同才算相同的数组，才能比较a :=[2]int&#123;1,2&#125;b :=[2]int&#123;3,2&#125;// 使用new关键字，返回指向数组的指针a :=[2]int&#123;&#125;a[1] = 2b = new([2]int)b[1] = 2// 不论是指向数组的指针还是数组本身，都可以使用a[1]的形式给数组赋值// go语言的数组是值类型，不是引用类型//冒泡排序func main() &#123; list := [...]int&#123;12, 323, 4, 565, 67, 3&#125; fmt.Println(list) var lenth = len(list) for i := 0; i &lt; lenth; i++ &#123; for j := i + 1; j &lt; lenth; j++ &#123; if list[i] &gt; list[j] &#123; tmp := list[i] list[i] = list[j] list[j] = tmp &#125; &#125; &#125; fmt.Println(list)&#125;// 结果：➜ first go run helloworld.go[12 323 4 565 67 3][3 4 12 67 323 565] 切片切片与数组的定义区别12345678vs:=[]interface&#123;&#125;&#123; []int&#123;&#125;,// slice 切片 []int&#123;1,2,3&#125;,// slice 切片 []int&#123;1,2,3&#125;[:],//切片再切还是切片 make([]int,3,10),//标准的slice 定义方式 [3]int&#123;1,2,3&#125;,//array 数组，确定数组长度 [...]int&#123;1,2,3&#125;,//array 数组，由编译器自动计算数组长度。&#125; Reslice 切片本质上是指向类型 切片不能越界，如果超过底层数组，则报错，而不是追加数组长度 索引不可超多数组容量123456789101112131415a := [10]int&#123;1,2,3,4,5,6,7,8,9&#125;fpm.Prinln(a)// 0~4 容量为10s1 := a[:5]// 5-9, 索引5到索引9,索引10不取， 容量为5s1 := a[5,10]// 使用make,// 参数1：类型，// 参数2：包含几个元素，// 参数3：容量（先分配10个连续内存地址，如果增加到11个时，则需要从新分配，每次增加一倍，扩容至20，下次40，在下次80，造成这种现象的原因是因为：从新分配内存是一件效率非常低的）如果留空，则和参数相等s1 := make([]int,3,10)// 获取切片的长度, len(s1)// 获取切片容量map(s1) Append 可以在slice尾部追加元素 可以将一个slice追加到另一个slice 如果最终长度未超过追加到slice的容量，则返回原始slice 如果超过追加的slice的容量，将重新分配数据1234567891011121314151617s1 := make([]int, 3, 6)fmt.Printf("%p\n", s1)s1 = append(s1, 1, 2, 3)fmt.Printf("%v %p\n", s1, s1)s1 = append(s1, 1, 2, 3)fmt.Printf("%v %p\n", s1, s1)// 对于指向同一个数组的slice，如果数组改变了，则两个slice指向的部分同样改变a := []int&#123;1, 2, 3, 4, 5&#125;s1 := a[2:5]s2 := a[1:3]fmt.Println(s1, s2)s1[0] = 9fmt.Println(s1, s2)// 结果：➜ first go run helloworld.go[3 4 5] [2 3][9 4 5] [2 9] 如果一个slice通过append添加时，如果超过了容量，那么就不在指向原来的数组，而是从新分配了一个12345678910111213func main() &#123; a := []int&#123;1, 2, 3, 4, 5&#125; s1 := a[2:5] s2 := a[1:3] fmt.Println(s1, s2) s2 = append(s2, 1, 2, 3, 4, 5, 5, 6, 6, 7) s1[0] = 9 fmt.Println(s1, s2)&#125;// 结果：➜ first go run helloworld.go[3 4 5] [2 3][9 4 5] [2 3 1 2 3 4 5 5 6 6 7] copy 从参数2复制到参数1（覆盖） 该函数主要是切片（slice）的拷贝，不支持数组 将第二个slice里的元素拷贝到第一个slice里，拷贝的长度为两个slice中长度较小的长度值12345678910111213141516s1 := []int&#123;1, 2, 3, 4, 5, 6&#125;s2 := []int&#123;7, 8, 9&#125;copy(s2, s1)copy(s1, s2)fmt.Println(s2, s1)// 结果➜ first go run helloworld.go[1 2 3] [1 2 3 4 5 6]// 当然可以指定位置s1 := []int&#123;1, 2, 3, 4, 5, 6&#125;s2 := []int&#123;7, 8, 9&#125;copy(s1[3:6], s2)fmt.Println(s1)// 结果：➜ first go run helloworld.go[1 2 3 7 8 9] 删除切片12// 比如想删除下标为k的切片arr = append(arr[:k], arr[k+1:]...) map map是无序的1234567891011121314151617181920212223242526272829303132333435363738394041424344// 初始化mapm := map[int]string&#123;1: "zhangsan", 2: "lisi", 3: "wangwu", 4: "zhaoliu"&#125;// 初始化slices := make([]int, len(m))i := 0// range 可遍历slice或mapfor k, _ := range m &#123; // 将map的键赋给slice s[i] = k i++&#125;fmt.Println(s)//结果（体现了map的无序性）➜ first go run helloworld.go[1 2 3 4]➜ first go run helloworld.go[4 1 2 3]// 如果使用range遍历slice和map，func main() &#123; m := map[int]string&#123;1: "zhangsan", 2: "lisi", 3: "wangwu", 4: "zhaoliu"&#125; s := make([]int, len(m)) i := 0 for k, v := range m &#123; s[i] = k i++ fmt.Println(k, v) &#125; fmt.Println(s) for k, v := range s &#123; fmt.Println(k, v) &#125;&#125;// 结果如下：➜ first go run helloworld.go4 zhaoliu1 zhangsan2 lisi3 wangwu[4 1 2 3]0 41 12 23 3]]></content>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小坑]]></title>
    <url>%2Fgolang%2F%E5%B0%8F%E5%9D%91%2F</url>
    <content type="text"><![CDATA[:=如下函数：12345678910111213141516171819202122232425262728func GetAll(sql string) (records []interface&#123;&#125;, err error) &#123; query, err := DB.Query(sql) if err != nil &#123; return &#125; column, _ := query.Columns() scans := make([]interface&#123;&#125;, len(column)) values := make([]interface&#123;&#125;, len(column)) for i := range values &#123; scans[i] = &amp;values[i] &#125; for query.Next() &#123; // 如果此处写成err := query.Scan(scans...)。 // 那么在此作用域内，err 和 外层作用域不同，return会报错 err = query.Scan(scans...) if err != nil &#123; return &#125; record := make(map[string]string) for i, col := range values &#123; if col != nil &#123; record[column[i]] = string(col.([]byte)) &#125; &#125; records = append(records, record) &#125; return&#125; mysql NULL 值如果mysql的某个值为null，go查询数据库时则会报错：1sql: Scan error on column index 2: unsupported Scan, storing driver.Value type &lt;nil&gt; into type *string 解决办法： 对于可能为NULL的字段读取，go的sql模块提供了一个sql.NullString这样的东东来解析可能为NULL的字符串，对于浮点型或者整形也有类似的数据类型。很蛋疼的样子，不过可以解决问题，下面是遵照这种方案进行的修改。 123456789rows.Next() &#123; var id int var name, info sql.NullString if err = rows.Scan(&amp;id, &amp;name, &amp;info); err != nil &#123; fmt.Println("获取结果出错：" + err.Error()) return &#125; fmt.Println("id:", id, "name:", name.String, "info:", info.String)&#125; sql语句本身也能解决这种问题此时也不需要修改go代码，继续保持go的强类型风格 1SELECT id, IFNULL(`name`, '') AS `name`, IFNULL(info, '') AS info FROM user]]></content>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发编程（1）]]></title>
    <url>%2Fgolang%2F%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Goroutinedemo12345678910111213141516171819202122232425262728293031type c struct &#123; word string wordId int err error place int&#125;func main() &#123; cpunum := runtime.NumCPU() runtime.GOMAXPROCS(cpunum) ch := make(chan c, 100) t1 := time.Now().Unix() for i := 0; i &lt; 300; i++ &#123; go test(i, ch) &#125; for i := 0; i &lt; 300; i++ &#123; select &#123; case res := &lt;-ch: fmt.Println(res) &#125; &#125; t2 := time.Now().Unix() log.Println(t2, t1)&#125;func test(i int, ch chan c) &#123; time.Sleep(time.Second) res := c&#123;"test", i, nil, 0&#125; ch &lt;- res return&#125; Channel操作符&lt;-如果通过管道发送一个值，则将&lt;-作为二元操作符使用。通过管道接收一个值，则将其作为一元操作符使用:12ic &lt;- 3 // 往管道发送3work := &lt;-wc // 从管道接收一个指向Work类型值的指针 channel特点 Channel是Goroutine沟通的桥梁，大部分是阻塞同步的 通过make创建，close关闭 channel是引用类型 可以使用for range来迭代不断的操作 可以设置单向或双向通道 可以设置缓存大小，在未被填满之前不会发生阻塞 通道阻塞 对于无缓冲的channel,通道的发送/接收操作在对方准备好之前是阻塞 对于同一个通道，发送操作（协程或者函数中的），在接收者准备好之前是阻塞的：如果ch中的数据无人接收，就无法再给通道传入其他数据：新的输入无法在通道非空的情况下传入。所以发送操作会等待 ch 再次变为可用状态：就是通道值被接收时（可以传入变量）。 对于同一个通道，接收操作是阻塞的（协程或函数中的），直到发送者可用：如果通道中没有数据，接收者就阻塞了。1234567891011121314151617package mainimport "fmt"func main() &#123; ch1 := make(chan int) go pump(ch1) // pump hangs // 只是接受结果一次，也就是说，下面的send方再插入一个1，2就插入不进去了，阻塞了 fmt.Println(&lt;-ch1) // prints only 0&#125;func pump(ch chan int) &#123; for i := 0; ; i++ &#123; ch &lt;- i &#125;&#125;// 结果：0 常见错误示例：123456789101112131415package mainimport ( "fmt")func f1(in chan int) &#123; fmt.Println(&lt;-in)&#125;func main() &#123; out := make(chan int) out &lt;- 2 go f1(out)&#125; 上述例子会照成死锁，原因很简单，一般通讯的话，有两种情况 没有缓冲时，需要最少两个goroutine准备好 有缓冲时，则是goroutine - 中间缓冲层 - goroutine之间的连接。 demo实例123456789101112131415161718192021func main() &#123; // 使用make创建一个channel channel := make(chan bool) go func() &#123; fmt.Println("gogogo") // 向channel存数据 channel &lt;- true // 关闭channel close(channel) &#125;() // 迭代channel for v := range channel &#123; fmt.Println(v) &#125; fmt.Println("this is base")&#125;// 结果➜ first go run helloworld.gogogogotruethis is base 由结果可以看出：先迭代完成才会进行下一步操作， 也就是说，迭代的过程是阻塞的，如果channel中没有值，迭代就会一直等待，一直等到它有值，如果channel没有关闭，则会发生死锁（deadlock） 带缓冲的channel12345678910111213141516171819202122func main() &#123; ch := make(chan string, 4) ch &lt;- "zhangsan1" ch &lt;- "zhangsan2" ch &lt;- "zhangsan3" ch &lt;- "zhangsan4" // 如果加上这一行，则会死锁，是因为当超过缓冲区的时候，就成阻塞模式了 //ch &lt;- "zhangsan5" close(ch) fmt.Println(&lt;-ch) fmt.Println(&lt;-ch) fmt.Println(&lt;-ch) fmt.Println(&lt;-ch) fmt.Println(&lt;-ch)&#125;// 结果➜ first go run helloworld.gozhangsan1zhangsan2zhangsan3zhangsan4 // 此处为string零值 可以看出带缓冲的channel略有不同。尽管已经close了，但我们依旧可以从中读出关闭前写入的3个值。第四次读取时，则会返回该channel类型的零值。向这类channel写入操作也会触发panic。 channel常与range配合12345678910111213141516func main() &#123; ch := make(chan string) go generate(ch) for v := range ch &#123; fmt.Printf("%s\n", v) &#125;&#125;func generate(ch chan string) &#123; ch &lt;- "zhangsan1" ch &lt;- "zhangsan2" ch &lt;- "zhangsan3" ch &lt;- "zhangsan4" ch &lt;- "zhangsan5" close(ch)&#125; channel实际用途可用作信号源12345678910func main() &#123; fmt.Println("Begin doing something!") c := make(chan bool) go func() &#123; fmt.Println("Doing something…") close(c) &#125;() &lt;-c fmt.Println("Done!")&#125; 协同多个Goroutines 同上，close channel还可以用于协同多个Goroutines，比如下面这个例子，我们创建了100个Worker Goroutine，这些Goroutine在被创建出来后都阻塞在”&lt;-start”上，直到我们在main goroutine中给出开工的信号：”close(start)”，这些goroutines才开始真正的并发运行起来。12345678910111213func worker(start chan bool, index int) &#123; &lt;-start fmt.Println("This is Worker:", index)&#125;func main() &#123; start := make(chan bool) for i := 1; i &lt;= 100; i++ &#123; go worker(start, i) &#125; close(start) select &#123;&#125; //deadlock we expected&#125; 唯一的ID服务1234567891011121314151617181920212223242526272829303132333435package mainimport "fmt"func newUniqueIDService() &lt;-chan string &#123; id := make(chan string) go func() &#123; var counter int64 = 0 for &#123; // 无缓冲 -&gt; 阻塞 id &lt;- fmt.Sprintf("%x", counter) counter += 1 &#125; &#125;() return id&#125;func main() &#123; id := newUniqueIDService() for i := 0; i &lt; 10; i++ &#123; // 这边取一个，id插入一个（自增） fmt.Println(&lt;-id) &#125;&#125;$ go run testuniqueid.go0123456789 selectselect特点 可以处理一个或多个channel的发送与接收 同时有多个可用的channel时按随机顺序处理 可用空的select阻塞main函数 可设置超时 惯用法：for/select 我们在使用select时很少只是对其进行一次evaluation，我们常常将其与for {}结合在一起使用，并选择适当时机从for{}中退出。12345678910111213141516for &#123; select &#123; case x := &lt;- somechan: // … 使用x进行一些操作 case y, ok := &lt;- someOtherchan: // … 使用y进行一些操作， // 检查ok值判断someOtherchan是否已经关闭 case outputChan &lt;- z: // … z值被成功发送到Channel上时 default: // … 上面case均无法通信时，执行此分支 &#125;&#125; 终结workers12345678910111213141516171819202122func main() &#123; ch, die := make(chan bool), make(chan bool) for i := 0; i &lt; 10; i++ &#123; go worker(die, i, ch) ch &lt;- true &#125; time.Sleep(1 * time.Second) // 此处终结worker close(die)&#125;func worker(die chan bool, index int, ch chan bool) &#123; fmt.Println("Begin: This is Worker:", index) for &#123; select &#123; case &lt;-ch: fmt.Println("already worded:", index) case &lt;-die: return &#125; &#125;&#125; 终结验证12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package mainimport ( "fmt" //"time")func worker(die chan bool) &#123; fmt.Println("Begin: This is Worker") for &#123; select &#123; //case xx： //做事的分支 // get channel message case &lt;-die: fmt.Println("Done: This is Worker") // send channel message die &lt;- true return &#125; &#125;&#125;func main() &#123; die := make(chan bool) go worker(die) // send channel message die &lt;- true // get channel message &lt;-die fmt.Println("Worker goroutine has been terminated")&#125;``` # 等待goroutine完成使用`sync`包```gofunc correct() &#123; var wg sync.WaitGroup wg.Add(5) for i := 0; i &lt; 5; i++ &#123; go func(n int) &#123; // 使用局部变量 fmt.Print(n) wg.Done() &#125;(i) &#125; wg.Wait() fmt.Println()&#125; 上述只是等待goroutine完成，却没有进行通讯。有错误值也无法返回。所以说，最好还是使用channel如果我们希望通讯，只需要在此基础上增加channel通讯即可例：123456789101112131415161718192021222324252627func main() &#123; people := []string&#123;"Anna", "Bob", "Cody", "Dave", "Eva"&#125; match := make(chan string, 1) // 为一个未匹配的发送操作提供空间 wg := new(sync.WaitGroup) wg.Add(len(people)) for _, name := range people &#123; go Seek(name, match, wg) &#125; wg.Wait() select &#123; case name := &lt;-match: fmt.Printf("No one received %s’s message.\n", name) default: // 没有待处理的发送操作 &#125;&#125;// 函数Seek 发送一个name到match管道或从match管道接收一个peer，结束时通知wait groupfunc Seek(name string, match chan string, wg *sync.WaitGroup) &#123; select &#123; case peer := &lt;-match: fmt.Printf("%s sent a message to %s.\n", peer, name) case match &lt;- name: // 等待某个goroutine接收我的消息 &#125; wg.Done()&#125; 利用多核1234func init() &#123; numcpu := runtime.NumCPU() runtime.GOMAXPROCS(numcpu) // 尝试使用所有可用的CPU&#125;]]></content>
      <tags>
        <tag>go</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webServer]]></title>
    <url>%2Fgolang%2FwebServer%2F</url>
    <content type="text"><![CDATA[通过默认的net/http服务12345678910111213func main() &#123; http.HandleFunc("/", HelloWorld) errpr := http.ListenAndServe(":8080", nil) if errpr != nil &#123; log.Fatal("listen falded") &#125;&#125;// 由于http.ResponseWriter只是一个接口,所以不需要引用传值// 而http.Request是一个数据(结构类型),所以需要引用传值func HelloWorld(w http.ResponseWriter, r *http.Request) &#123; io.WriteString(w, "hello world")&#125; 重写ServeHTTP方法123456789101112131415161718type MyHandler struct &#123;&#125;func main() &#123; mux := http.NewServeMux() mux.Handle("/", &amp;MyHandler&#123;&#125;) mux.HandleFunc("/home", Home) err := http.ListenAndServe(":8080", mux) if err != nil &#123; log.Fatal("listen falded") &#125;&#125;func (this *MyHandler)ServeHTTP(w http.ResponseWriter, r *http.Request) &#123; io.WriteString(w, "hello world " + r.URL.Path)&#125;func Home(w http.ResponseWriter, r *http.Request) &#123; io.WriteString(w, "home " + r.URL.Path)&#125; 重写http.Server1234567891011121314151617181920212223242526272829303132333435363738// 定义全局变量var mux map[string]func(http.ResponseWriter, *http.Request)type MyHandler struct&#123;&#125;func main() &#123; server := http.Server&#123; Addr: ":8080", // 定义server的默认handler Handler: &amp;MyHandler&#123;&#125;, ReadTimeout: 2 * time.Second, &#125; // 对全局变量赋值 mux = make(map[string]func(http.ResponseWriter, *http.Request)) mux["/home"] = Home mux["/user"] = User err := server.ListenAndServe() if err != nil &#123; log.Fatal("listen faild") &#125;&#125;// handler默认执行的方法func (*MyHandler)ServeHTTP(w http.ResponseWriter, r *http.Request) &#123; // 根据map转发路由 if v, ok := mux[r.URL.String()]; ok &#123; v(w, r) return &#125; io.WriteString(w, "hello world " + r.URL.Path)&#125;func Home(w http.ResponseWriter, r *http.Request) &#123; io.WriteString(w, "home " + r.URL.Path)&#125;func User(w http.ResponseWriter, r *http.Request) &#123; io.WriteString(w, "user " + r.URL.Path)&#125; 原生中间件编写123456789101112131415161718192021222324252627282930313233343536373839404142434445464748package mainimport ( "net/http" "fmt")type SingleMiddle struct &#123; handler http.Handler allowHost []string&#125;type myHandler struct&#123;&#125;func main() &#123; var allowHosts []string allowHosts = append(allowHosts, "localhost:8080") MyHandler := &amp;myHandler&#123;&#125; singleHost := NewSingle(MyHandler, allowHosts) http.ListenAndServe(":8080", singleHost)&#125;// middlewarefunc NewSingle(handler http.Handler, allowHost []string) (*SingleMiddle) &#123; return &amp;SingleMiddle&#123;handler, allowHost&#125;&#125;// middlewarefunc (s *SingleMiddle) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123; host := r.Host isIn := false fmt.Println(s.allowHost) fmt.Println(host) for _, allowH := range s.allowHost &#123; if allowH == host &#123; isIn = true &#125; &#125; if isIn &#123; s.handler.ServeHTTP(w, r) &#125; else &#123; w.WriteHeader(403) &#125;&#125;// custom handlerfunc (m *myHandler) ServeHTTP(w http.ResponseWriter, r *http.Request) &#123; w.WriteHeader(200) w.Write([]byte("helle golang"))&#125;]]></content>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发编程（2）]]></title>
    <url>%2Fgolang%2F%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%A4%BA%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[并发编程示例定时任务12345678910111213141516171819func demo(input chan interface&#123;&#125;) &#123; t1 := time.NewTimer(time.Second * 5) t2 := time.NewTimer(time.Second * 10) for &#123; select &#123; case msg &lt;- input: println(msg) case &lt;-t1.C: println("5s timer") t1.Reset(time.Second * 5) case &lt;-t2.C: println("10s timer") t2.Reset(time.Second * 10) &#125; &#125;&#125; 断续器123456func main()&#123; ticker := time.NewTicker(time.Second) for t := range ticker.C &#123; fmt.Println("ticker", t) &#125;&#125; 超时123456789101112131415func main()&#123; ch1 := make(chan int, 1) ch2 := make(chan int, 1) select &#123; case e1 := &lt;-ch1: //如果ch1通道成功读取数据，则执行该case处理语句 fmt.Printf("1th case is selected. e1=%v",e1) case e2 := &lt;-ch2: //如果ch2通道成功读取数据，则执行该case处理语句 fmt.Printf("2th case is selected. e2=%v",e2) case &lt;- time.After(2 * time.Second): fmt.Println("Timed out") &#125;&#125; 自定义定时器12345678910111213func main()&#123; var t *time.Timer f := func()&#123; fmt.Printf("Expiration time : %v.\n", time.Now()) fmt.Printf("C`s len: %d\n", len(t.C)) &#125; t = time.AfterFunc(1*time.Second, f) //让当前Goroutine 睡眠2s，确保大于内容的完整 //这样做原因是，time.AfterFunc的调用不会被阻塞。它会以一部的方式在到期事件来临执行我们自定义函数f。 time.Sleep(2 * time.Second)&#125; 使用时间控制停止ticker1234567891011121314func main()&#123; //初始化断续器,间隔2s var ticker *time.Ticker = time.NewTicker(1 * time.Second) go func() &#123; for t := range ticker.C &#123; fmt.Println("Tick at", t) &#125; &#125;() time.Sleep(time.Second * 5) //阻塞，则执行次数为sleep的休眠时间/ticker的时间 ticker.Stop() //停止ticker fmt.Println("Ticker stopped")&#125; 并发读取文件夹所有文件的长度（使用通道）12345678910111213141516171819202122232425262728293031323334353637383940func test1() &#123; // 遍历文件夹，获取文件名 dir := "./db" paths, err := ioutil.ReadDir(dir) check(err) var files []string for _, path := range paths &#123; if !path.IsDir() &#123; files = append(files, path.Name()) &#125; &#125; type FileInfo struct &#123; FileName string Len int Err error &#125; way := make(chan FileInfo, 100) for _, file := range files &#123; go func(fileName string) &#123; content, err := ioutil.ReadFile(fmt.Sprintf("%s/%s", dir, fileName)) // 无论对错，都交给通道收取方 way &lt;- FileInfo&#123; FileName: fileName, Len: len(content), Err: err, &#125; &#125;(file) &#125; // 我们知道需要从通道中取多少条数据 for i := 0; i &lt; len(files); i++ &#123; fileInfo := &lt;-way if fileInfo.Err != nil &#123; fmt.Printf("[err] file:%s, err: %s \n", fileInfo.FileName, fileInfo.Err.Error()) return &#125; fmt.Printf("file:%s, len: %d \n", fileInfo.FileName, fileInfo.Len) &#125;&#125; 并发读取 文件夹所有文件的长度（使用sync.WaitGroup）这个使用的其实就是计数器的道理12345678910111213141516171819202122232425262728293031323334func test1() &#123; dir := "./db" paths, err := ioutil.ReadDir(dir) check(err) var files []string for _, path := range paths &#123; if !path.IsDir() &#123; files = append(files, path.Name()) &#125; &#125; // sizes用来计算总长度和阻塞直至所有goroutine走完 sizes := make(chan int64) // 计数器 var wg sync.WaitGroup for _, file := range files &#123; wg.Add(1) go func(fileName string) &#123; defer wg.Done() fileInfo, _ := os.Stat(fmt.Sprintf("%s/%s", dir, fileName)) sizes &lt;- fileInfo.Size() &#125;(file) &#125; go func() &#123; wg.Wait() close(sizes) &#125;() var total int64 for size := range sizes &#123; fmt.Printf("size:%d\n", size) total += size &#125; fmt.Printf("total size: %d\n", total)&#125; 令牌-另一种信号计数器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192func check(err error) &#123; if err != nil &#123; panic(err) &#125;&#125;func main() &#123; // 链接列表 workList := make(chan []string) // 存储 已经处理的 链接，使用 map是为了去重 seen := make(map[string]bool) // n是为了保证 爬虫一直 爬 n := 1 // 初始化 go func() &#123; workList &lt;- []string&#123;"http://www.jianshu.com"&#125; &#125;() for i := n; i &gt; 0; i++ &#123; list := &lt;-workList for _, link := range list &#123; if !seen[link] &#123; seen[link] = true n++ go func(link string) &#123; workList &lt;- crawl(link) &#125;(link) &#125; &#125; &#125;&#125;var tokens = make(chan struct&#123;&#125;, 20)// 获取网页的链接 通过令牌func crawl(url string) (list []string) &#123; fmt.Println(url) tokens &lt;- struct&#123;&#125;&#123;&#125; list, err := Extract(url) &lt;-tokens if err != nil &#123; log.Print(err) return &#125; return&#125;// 获取网页的链接func Extract(url string) (list []string, err error) &#123; resp, err := http.Get(url) if err != nil &#123; return &#125; if resp.StatusCode != http.StatusOK &#123; resp.Body.Close() return nil, fmt.Errorf("getting %s, err %s", url, err.Error()) &#125; doc, err := html.Parse(resp.Body) resp.Body.Close() if err != nil &#123; return nil, fmt.Errorf("parsing %s as HTML, err %s", url, err.Error()) &#125; visitNode := func(n *html.Node) &#123; if n.Type == html.ElementNode &amp;&amp; n.Data == "a" &#123; for _, a := range n.Attr &#123; if a.Key != "href" &#123; continue &#125; link, err := resp.Request.URL.Parse(a.Val) if err != nil &#123; continue &#125; list = append(list, link.String()) &#125; &#125; &#125; // 将函数作为参数传入 （匿名函数） forEachNode(doc, visitNode, nil) return&#125;func forEachNode(n *html.Node, pre, next func(node *html.Node)) &#123; if pre != nil &#123; pre(n) &#125; for n := n.FirstChild; n != nil; n = n.NextSibling &#123; forEachNode(n, pre, next) &#125; if next != nil &#123; next(n) &#125;&#125;]]></content>
      <tags>
        <tag>go</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据类型判断与转换]]></title>
    <url>%2Fgolang%2F%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD%E4%B8%8E%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[int int64 string之间转换12345678#string到int int,err:=strconv.Atoi(string) #string到int64 int64, err := strconv.ParseInt(string, 10, 64) #int到string string:=strconv.Itoa(int) #int64到string string:=strconv.FormatInt(int64,10) 断言value, ok = element.(T) demo1123456var a interface&#123;&#125;a = "zhangsan"// interface&#123;&#125; =&gt; string (断言)a = a.(string)// 如果直接string(a), 则报错:cannot convert a (type interface &#123;&#125;) to type string: need type assertion demo21234567891011121314func main() &#123; for index, element := range list &#123; if value, ok := element.(int); ok &#123; fmt.Printf("list[%d] is an int and its value is %d\n", index, value) &#125; else if value, ok := element.(string); ok &#123; fmt.Printf("list[%d] is a string and its value is %s\n", index, value) &#125; else if value, ok := element.(Person); ok &#123; fmt.Printf("list[%d] is a Person and its value is %s\n", index, value) &#125; else &#123; fmt.Println("list[%d] is of a different type", index) &#125; &#125;&#125; demo312345678910111213141516func main() &#123; for index, element := range list&#123; switch value := element.(type) &#123; case int: fmt.Printf("list[%d] is an int and its value is %d\n", index, value) case string: fmt.Printf("list[%d] is a string and its value is %s\n", index, value) case Person: fmt.Printf("list[%d] is a Person and its value is %s\n", index, value) default: fmt.Println("list[%d] is of a different type", index) &#125; &#125;&#125;]]></content>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件处理]]></title>
    <url>%2Fgolang%2F%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[遍历目录使用ioutil标准包123456789101112func ListDir(filePath string) (files []string, err error) &#123; paths, err := ioutil.ReadDir(filePath) if err != nil &#123; return &#125; for _, f := range paths &#123; if !f.IsDir() &#123; files = append(files, f.Name()) &#125; &#125; return&#125;]]></content>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2Fgolang%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[用法单一：12345678910111213141516. 匹配任意一个字符，如果设置 s = true，则可以匹配换行符[字符类] 匹配“字符类”中的一个字符，“字符类”见后面的说明[^字符类] 匹配“字符类”外的一个字符，“字符类”见后面的说明\小写Perl标记 匹配“Perl类”中的一个字符，“Perl类”见后面的说明\大写Perl标记 匹配“Perl类”外的一个字符，“Perl类”见后面的说明[:ASCII类名:] 匹配“ASCII类”中的一个字符，“ASCII类”见后面的说明[:^ASCII类名:] 匹配“ASCII类”外的一个字符，“ASCII类”见后面的说明\pUnicode普通类名 匹配“Unicode类”中的一个字符(仅普通类)，“Unicode类”见后面的说明\PUnicode普通类名 匹配“Unicode类”外的一个字符(仅普通类)，“Unicode类”见后面的说明\p&#123;Unicode类名&#125; 匹配“Unicode类”中的一个字符，“Unicode类”见后面的说明\P&#123;Unicode类名&#125; 匹配“Unicode类”外的一个字符，“Unicode类”见后面的说明 复合12xy 匹配 xy（x 后面跟随 y）x|y 匹配 x 或 y (优先匹配 x) 重复123456789101112x* 匹配零个或多个 x，优先匹配更多(贪婪)x+ 匹配一个或多个 x，优先匹配更多(贪婪)x? 匹配零个或一个 x，优先匹配一个(贪婪)x&#123;n,m&#125; 匹配 n 到 m 个 x，优先匹配更多(贪婪)x&#123;n,&#125; 匹配 n 个或多个 x，优先匹配更多(贪婪)x&#123;n&#125; 只匹配 n 个 xx*? 匹配零个或多个 x，优先匹配更少(非贪婪)x+? 匹配一个或多个 x，优先匹配更少(非贪婪)x?? 匹配零个或一个 x，优先匹配零个(非贪婪)x&#123;n,m&#125;? 匹配 n 到 m 个 x，优先匹配更少(非贪婪)x&#123;n,&#125;? 匹配 n 个或多个 x，优先匹配更少(非贪婪)x&#123;n&#125;? 只匹配 n 个 x 分组12345678910111213141516(子表达式) 被捕获的组，该组被编号 (子匹配)(?P&lt;命名&gt;子表达式) 被捕获的组，该组被编号且被命名 (子匹配)(?:子表达式) 非捕获的组 (子匹配)(?标记) 在组内设置标记，非捕获，标记影响当前组后的正则表达式(?标记:子表达式) 在组内设置标记，非捕获，标记影响当前组内的子表达式标记的语法是：xyz (设置 xyz 标记)-xyz (清除 xyz 标记)xy-z (设置 xy 标记, 清除 z 标记)可以设置的标记有：i 不区分大小写 (默认为 false)m 多行模式：让 ^ 和 $ 匹配整个文本的开头和结尾，而非行首和行尾(默认为 false)s 让 . 匹配 \n (默认为 false)U 非贪婪模式：交换 x* 和 x*? 等的含义 (默认为 false) 位置标记：123456^ 如果标记 m=true 则匹配行首，否则匹配整个文本的开头（m 默认为 false）$ 如果标记 m=true 则匹配行尾，否则匹配整个文本的结尾（m 默认为 false）\A 匹配整个文本的开头，忽略 m 标记\b 匹配单词边界\B 匹配非单词边界\z 匹配整个文本的结尾，忽略 m 标记 转序标记123456789101112131415161718192021222324252627\a 匹配响铃符 （相当于 \x07） 注意：正则表达式中不能使用 \b 匹配退格符，因为 \b 被用来匹配单词边界， 可以使用 \x08 表示退格符。\f 匹配换页符 （相当于 \x0C）\t 匹配横向制表符（相当于 \x09）\n 匹配换行符 （相当于 \x0A）\r 匹配回车符 （相当于 \x0D）\v 匹配纵向制表符（相当于 \x0B）\123 匹配 8 進制编码所代表的字符（必须是 3 位数字）\x7F 匹配 16 進制编码所代表的字符（必须是 3 位数字）\x&#123;10FFFF&#125; 匹配 16 進制编码所代表的字符（最大值 10FFFF ）\Q...\E 匹配 \Q 和 \E 之间的文本，忽略文本中的正则语法\\ 匹配字符 \\^ 匹配字符 ^\$ 匹配字符 $\. 匹配字符 .\* 匹配字符 *\+ 匹配字符 +\? 匹配字符 ?\&#123; 匹配字符 &#123;\&#125; 匹配字符 &#125;\( 匹配字符 (\) 匹配字符 )\[ 匹配字符 [\] 匹配字符 ]\| 匹配字符 | 可以将“命名字符类”作为“字符类”的元素：12345678[\d] 匹配数字 (相当于 \d)[^\d] 匹配非数字 (相当于 \D)[\D] 匹配非数字 (相当于 \D)[^\D] 匹配数字 (相当于 \d)[[:name:]] 命名的“ASCII 类”包含在“字符类”中 (相当于 [:name:])[^[:name:]] 命名的“ASCII 类”不包含在“字符类”中 (相当于 [:^name:])[\p&#123;Name&#125;] 命名的“Unicode 类”包含在“字符类”中 (相当于 \p&#123;Name&#125;)[^\p&#123;Name&#125;] 命名的“Unicode 类”不包含在“字符类”中 (相当于 \P&#123;Name&#125;) 说明字符类取值如下（字符类包含Perl类、ASCII类、Unicode类）： x 单个字符 A-Z 字符范围(包含首尾字符) \小写字母 Perl类 [:ASCII类名:] ASCII类 \p{Unicode脚本类名} Unicode类 (脚本类) \pUnicode普通类名 Unicode类 (普通类) “Perl 类”取值如下：123456\d 数字 (相当于 [0-9])\D 非数字 (相当于 [^0-9])\s 空白 (相当于 [\t\n\f\r ])\S 非空白 (相当于[^\t\n\f\r ])\w 单词字符 (相当于 [0-9A-Za-z_])\W 非单词字符 (相当于 [^0-9A-Za-z_]) “ASCII 类”取值如下1234567891011121314[:alnum:] 字母数字 (相当于 [0-9A-Za-z])[:alpha:] 字母 (相当于 [A-Za-z])[:ascii:] ASCII 字符集 (相当于 [\x00-\x7F])[:blank:] 空白占位符 (相当于 [\t ])[:cntrl:] 控制字符 (相当于 [\x00-\x1F\x7F])[:digit:] 数字 (相当于 [0-9])[:graph:] 图形字符 (相当于 [!-~] 相当于 [A-Za-z0-9!&quot;# $%&amp;&apos;()*+,\-./:;&lt;=&gt;?@[\\\]^_`&#123;|&#125;~])[:lower:] 小写字母 (相当于 [a-z])[:print:] 可打印字符 (相当于 [ -~] 相当于 [ [:graph:]])[:punct:] 标点符号 (相当于 [!-/:-@[-`&#123;-~])[:space:] 空白字符(相当于 [\t\n\v\f\r ])[:upper:] 大写字母(相当于 [A-Z])[:word:] 单词字符(相当于 [0-9A-Za-z_])[:xdigit:] 16 進制字符集(相当于 [0-9A-Fa-f]) “Unicode 类”取值如下—普通类：123456789101112131415161718192021222324252627282930313233343536C -其他- (other)Cc 控制字符 (control)Cf 格式 (format)Co 私人使用区 (private use)Cs 代理区 (surrogate)L -字母- (letter)Ll 小写字母 (lowercase letter)Lm 修饰字母 (modifier letter)Lo 其它字母 (other letter)Lt 首字母大写字母 (titlecase letter)Lu 大写字母 (uppercase letter)M -标记- (mark)Mc 间距标记 (spacing mark)Me 关闭标记 (enclosing mark)Mn 非间距标记 (non-spacing mark)N -数字- (number)Nd 十進制数字 (decimal number)Nl 字母数字 (letter number)No 其它数字 (other number)P -标点- (punctuation)Pc 连接符标点 (connector punctuation)Pd 破折号标点符号 (dash punctuation)Pe 关闭的标点符号 (close punctuation)Pf 最后的标点符号 (final punctuation)Pi 最初的标点符号 (initial punctuation)Po 其他标点符号 (other punctuation)Ps 开放的标点符号 (open punctuation)S -符号- (symbol)Sc 货币符号 (currency symbol)Sk 修饰符号 (modifier symbol)Sm 数学符号 (math symbol)So 其他符号 (other symbol)Z -分隔符- (separator)Zl 行分隔符 (line separator)Zp 段落分隔符 (paragraph separator)Zs 空白分隔符 (space separator) “Unicode 类”取值如下—脚本类：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677Arabic 阿拉伯文Armenian 亚美尼亚文Balinese 巴厘岛文Bengali 孟加拉文Bopomofo 汉语拼音字母Braille 盲文Buginese 布吉文Buhid 布希德文Canadian_Aboriginal 加拿大土著文Carian 卡里亚文Cham 占族文Cherokee 切诺基文Common 普通的，字符不是特定于一个脚本Coptic 科普特文Cuneiform 楔形文字Cypriot 塞浦路斯文Cyrillic 斯拉夫文Deseret 犹他州文Devanagari 梵文Ethiopic 衣索比亚文Georgian 格鲁吉亚文Glagolitic 格拉哥里文Gothic 哥特文Greek 希腊Gujarati 古吉拉特文Gurmukhi 果鲁穆奇文Han 汉文Hangul 韩文Hanunoo 哈鲁喏文Hebrew 希伯来文Hiragana 平假名（日语）Inherited 继承前一个字符的脚本Kannada 坎那达文Katakana 片假名（日语）Kayah_Li 克耶字母Kharoshthi 卡罗须提文Khmer 高棉文Lao 老挝文Latin 拉丁文Lepcha 雷布查文Limbu 林布文Linear_B B类线形文字（古希腊）Lycian 利西亚文Lydian 吕底亚文Malayalam 马拉雅拉姆文Mongolian 蒙古文Myanmar 缅甸文New_Tai_Lue 新傣仂文Nko Nko文Ogham 欧甘文Ol_Chiki 桑塔利文Old_Italic 古意大利文Old_Persian 古波斯文Oriya 奥里亚文Osmanya 奥斯曼亚文Phags_Pa 八思巴文Phoenician 腓尼基文Rejang 拉让文Runic 古代北欧文字Saurashtra 索拉什特拉文（印度县城）Shavian 萧伯纳文Sinhala 僧伽罗文Sundanese 巽他文Syloti_Nagri 锡尔赫特文Syriac 叙利亚文Tagalog 塔加拉文Tagbanwa 塔格巴努亚文Tai_Le 德宏傣文Tamil 泰米尔文Telugu 泰卢固文Thaana 塔安那文Thai 泰文Tibetan 藏文Tifinagh 提非纳文Ugaritic 乌加里特文Vai 瓦伊文Yi 彝文 注意 对于 [a-z] 这样的正则表达式，如果要在 [] 中匹配 - ，可以将 - 放在 [] 的开头或结尾，例如 [-a-z] 或 [a-z-] 可以在 [] 中使用转义字符：\f、\t、\n、\r、\v、\377、\xFF、\x{10FFFF}、\、\^、\$、.、*、+、\?、{、}、(、)、[、]、|（具体含义见上面的说明） 如果在正则表达式中使用了分组，则在执行正则替换的时候，“替换内容”中可以使用 $1、${1}、$name、${name} 这样的“分组引用符”获取相应的分组内容。其中 $0 代表整个匹配项，$1 代表第 1 个分组，$2 代表第 2 个分组，……。 如果“分组引用符”是 $name 的形式，则在解析的时候，name 是取尽可能长的字符串，比如：$1x 相当于 ${1x}，而不是${1}x，再比如：$10 相当于 ${10}，而不是 ${1}0。 由于 $ 字符会被转义，所以要在“替换内容”中使用 $ 字符，可以用 \$ 代替。 上面介绍的正则表达式语法是“Perl 语法”，除了“Perl 语法”外，Go 语言中还有另一种“POSIX 语法”，“POSIX 语法”除了不能使用“Perl 类”之外，其它都一样。 示例：func main() { text := Hello 世界！123 Go.123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114// 查找连续的小写字母reg := regexp.MustCompile(`[a-z]+`)fmt.Printf("%q\n", reg.FindAllString(text, -1))// ["ello" "o"]// 查找连续的非小写字母reg = regexp.MustCompile(`[^a-z]+`)fmt.Printf("%q\n", reg.FindAllString(text, -1))// ["H" " 世界！123 G" "."]// 查找连续的单词字母reg = regexp.MustCompile(`[\w]+`)fmt.Printf("%q\n", reg.FindAllString(text, -1))// ["Hello" "123" "Go"]// 查找连续的非单词字母、非空白字符reg = regexp.MustCompile(`[^\w\s]+`)fmt.Printf("%q\n", reg.FindAllString(text, -1))// ["世界！" "."]// 查找连续的大写字母reg = regexp.MustCompile(`[[:upper:]]+`)fmt.Printf("%q\n", reg.FindAllString(text, -1))// ["H" "G"]// 查找连续的非 ASCII 字符reg = regexp.MustCompile(`[[:^ascii:]]+`)fmt.Printf("%q\n", reg.FindAllString(text, -1))// ["世界！"]// 查找连续的标点符号reg = regexp.MustCompile(`[\pP]+`)fmt.Printf("%q\n", reg.FindAllString(text, -1))// ["！" "."]// 查找连续的非标点符号字符reg = regexp.MustCompile(`[\PP]+`)fmt.Printf("%q\n", reg.FindAllString(text, -1))// ["Hello 世界" "123 Go"]// 查找连续的汉字reg = regexp.MustCompile(`[\p&#123;Han&#125;]+`)fmt.Printf("%q\n", reg.FindAllString(text, -1))// ["世界"]// 查找连续的非汉字字符reg = regexp.MustCompile(`[\P&#123;Han&#125;]+`)fmt.Printf("%q\n", reg.FindAllString(text, -1))// ["Hello " "！123 Go."]// 查找 Hello 或 Goreg = regexp.MustCompile(`Hello|Go`)fmt.Printf("%q\n", reg.FindAllString(text, -1))// ["Hello" "Go"]// 查找行首以 H 开头，以空格结尾的字符串reg = regexp.MustCompile(`^H.*\s`)fmt.Printf("%q\n", reg.FindAllString(text, -1))// ["Hello 世界！123 "]// 查找行首以 H 开头，以空白结尾的字符串（非贪婪模式）reg = regexp.MustCompile(`(?U)^H.*\s`)fmt.Printf("%q\n", reg.FindAllString(text, -1))// ["Hello "]// 查找以 hello 开头（忽略大小写），以 Go 结尾的字符串reg = regexp.MustCompile(`(?i:^hello).*Go`)fmt.Printf("%q\n", reg.FindAllString(text, -1))// ["Hello 世界！123 Go"]// 查找 Go.reg = regexp.MustCompile(`\QGo.\E`)fmt.Printf("%q\n", reg.FindAllString(text, -1))// ["Go."]// 查找从行首开始，以空格结尾的字符串（非贪婪模式）reg = regexp.MustCompile(`(?U)^.* `)fmt.Printf("%q\n", reg.FindAllString(text, -1))// ["Hello "]// 查找以空格开头，到行尾结束，中间不包含空格字符串reg = regexp.MustCompile(` [^ ]*$`)fmt.Printf("%q\n", reg.FindAllString(text, -1))// [" Go."]// 查找“单词边界”之间的字符串reg = regexp.MustCompile(`(?U)\b.+\b`)fmt.Printf("%q\n", reg.FindAllString(text, -1))// ["Hello" " 世界！" "123" " " "Go"]// 查找连续 1 次到 4 次的非空格字符，并以 o 结尾的字符串reg = regexp.MustCompile(`[^ ]&#123;1,4&#125;o`)fmt.Printf("%q\n", reg.FindAllString(text, -1))// ["Hello" "Go"]// 查找 Hello 或 Goreg = regexp.MustCompile(`(?:Hell|G)o`)fmt.Printf("%q\n", reg.FindAllString(text, -1))// ["Hello" "Go"]// 查找 Hello 或 Go，替换为 Hellooo、Goooreg = regexp.MustCompile(`(?PHell|G)o`)fmt.Printf("%q\n", reg.ReplaceAllString(text, "$&#123;n&#125;ooo"))// "Hellooo 世界！123 Gooo."// 交换 Hello 和 Goreg = regexp.MustCompile(`(Hello)(.*)(Go)`)fmt.Printf("%q\n", reg.ReplaceAllString(text, "$3$2$1"))// "Go 世界！123 Hello."// 特殊字符的查找reg = regexp.MustCompile("[\\f\\t\\n\\r\\v\\123\\x7F\\x&#123;10FFFF&#125;\\\\\\^\\$\\.\\*\\+\\?\\&#123;\\&#125;\\(\\)\\[\\]\\|]")fmt.Printf("%q\n", reg.ReplaceAllString("\f\t\n\r\v\123\x7F\U0010FFFF\\^$.*+?&#123;&#125;()[]|", "-"))// "----------------------"]]></content>
      <tags>
        <tag>go</tag>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串]]></title>
    <url>%2Fgolang%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[实现随机数12345678910111213func CreateRandom(strLen int) string &#123; strRandom := "qwertyuiopasdfghjklzxcvbnm1234567890QWERTYUIOPASDFGHJKLZXCVBNM" bytes := []byte(strRandom) strByte := []byte&#123;&#125; // 需要一个随机种子（torrent），不然每次都是一样的随机数 r := rand.New(rand.NewSource(time.Now().UnixNano())) for i := 0; i &lt; strLen; i++ &#123; subNum := r.Intn(len(bytes)) sep := bytes[subNum] strByte = append(strByte, sep) &#125; return string(strByte)&#125; MD5加密12345func Md5(str string) string &#123; m := md5.New() m.Write([]byte(str)) return hex.EncodeToString(m.Sum(nil))&#125;]]></content>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[docker-compose]]></title>
    <url>%2Fdocker%2Fdocker-compose%2F</url>
    <content type="text"><![CDATA[安装最为推荐：$ sudo pip install -U docker-compose之后，可以添加 bash 补全命令：curl -L https://raw.githubusercontent.com/docker/compose/1.2.0/contrib/completion/bash/docker-compose &gt; /etc/bash_completion.d/docker-compose 命令说明基本的使用格式是1docker-compose [options] [COMMAND] [ARGS...] 选项：1234--verbose 输出更多调试信息。--version 打印版本并退出。-f, --file FILE 使用特定的 compose 模板文件，默认为 docker-compose.yml。-p, --project-name NAME 指定项目名称，默认使用目录名称。 命令build构建或重新构建服务。服务一旦构建后，将会带上一个标记名，例如 web_db。可以随时在项目目录下运行 docker-compose build 来重新构建服务。 help获得一个命令的帮助。 kill通过发送 SIGKILL 信号来强制停止服务容器。支持通过参数来指定发送的信号，例如1$ docker-compose kill -s SIGINT logs查看服务的输出。 port打印绑定的公共端口。 ps列出所有容器。 pull拉取服务镜像。 rm删除停止的服务容器。 run在一个服务上执行一个命令。例如：1$ docker-compose run ubuntu ping docker.com 将会启动一个 ubuntu 服务，执行 ping docker.com 命令。默认情况下，所有关联的服务将会自动被启动，除非这些服务已经在运行中。该命令类似启动容器后运行指定的命令，相关卷、链接等等都将会按照期望创建。两个不同点： 给定命令将会覆盖原有的自动运行命令； 不会自动创建端口，以避免冲突。如果不希望自动启动关联的容器，可以使用 –no-deps 选项，例如12$ docker-compose run --no-deps web python manage.py shell将不会启动 web 容器所关联的其它容器。 scale设置同一个服务运行的容器个数。通过 service=num 的参数来设置数量。例如：1$ docker-compose scale web=2 worker=3 start启动一个已经存在的服务容器。 stop停止一个已经运行的容器，但不删除它。通过 docker-compose start 可以再次启动这些容器。 up构建，（重新）创建，启动，链接一个服务相关的容器。链接的服务都将会启动，除非他们已经运行。默认情况， docker-compose up 将会整合所有容器的输出，并且退出时，所有容器将会停止。如果使用 docker-compose up -d ，将会在后台启动并运行所有的容器。默认情况，如果该服务的容器已经存在， docker-compose up 将会停止并尝试重新创建他们（保持使用 volumes-from 挂载的卷），以保证 docker-compose.yml 的修改生效。如果你不想容器被停止并重新创建，可以使用 docker-compose up --no-recreate。如果需要的话，这样将会启动已经停止的容器。 YAML模板image指定为镜像名称或镜像 ID。如果镜像在本地不存在，Compose 将会尝试拉去这个镜像。例如：123image: ubuntuimage: orchardup/postgresqlimage: a4bc65fd build指定 Dockerfile 所在文件夹的路径。 Compose 将会利用它自动构建这个镜像，然后使用这个镜像。1build: /path/to/build/dir command覆盖容器启动后默认执行的命令。1command: bundle exec thin -p 3000 links链接到其它服务中的容器。使用服务名称（同时作为别名）或服务名称：服务别名 （SERVICE:ALIAS） 格式都可以。1234links: - db - db:database - redis 使用的别名将会自动在服务容器中的 /etc/hosts 里创建。例如：123172.17.2.186 db172.17.2.186 database172.17.2.187 redis 相应的环境变量也将被创建。 external_links链接到 docker-compose.yml 外部的容器，甚至 并非 Compose 管理的容器。参数格式跟 links 类似。1234external_links: - redis_1 - project_db_1:mysql - project_db_1:postgresql ports暴露端口信息。使用宿主：容器 （HOST:CONTAINER）格式或者仅仅指定容器的端口（宿主将会随机选择端口）都可以。12345ports: - &quot;3000&quot; - &quot;8000:8000&quot; - &quot;49100:22&quot; - &quot;127.0.0.1:8001:8001&quot; 注：当使用 HOST:CONTAINER 格式来映射端口时，如果你使用的容器端口小于 60 你可能会得到错误得结果，因为 YAML 将会解析 xx:yy 这种数字格式为 60 进制。所以建议采用字符串格式。 expose暴露端口，但不映射到宿主机，只被连接的服务访问。仅可以指定内部端口为参数123expose: - &quot;3000&quot; - &quot;8000&quot; volumes卷挂载路径设置。可以设置宿主机路径 （HOST:CONTAINER） 或加上访问模式 （HOST:CONTAINER:ro）。12345volumes: - /var/lib/mysql - cache/:/tmp/cache - ~/configs:/etc/configs/:rovolumes_from 从另一个服务或容器挂载它的所有卷。123volumes_from: - service_name - container_name environment设置环境变量。你可以使用数组或字典两种格式。只给定名称的变量会自动获取它在 Compose 主机上的值，可以用来防止泄露不必要的数据。123456environment: RACK_ENV: development SESSION_SECRET:environment: - RACK_ENV=development - SESSION_SECRET env_file从文件中获取环境变量，可以为单独的文件路径或列表。如果通过 docker-compose -f FILE 指定了模板文件，则 env_file 中路径会基于模板文件路径。如果有变量名称与 environment 指令冲突，则以后者为准。123456env_file: .envenv_file: - ./common.env - ./apps/web.env - /opt/secrets.env 环境变量文件中每一行必须符合格式，支持 # 开头的注释行。12# common.env: Set Rails/Rack environmentRACK_ENV=development extends基于已有的服务进行扩展。例如我们已经有了一个 webapp 服务，模板文件为 common.yml。123456# common.ymlwebapp: build: ./webapp environment: - DEBUG=false - SEND_EMAILS=false 编写一个新的 development.yml 文件，使用 common.yml 中的 webapp 服务进行扩展。12345678910111213# development.ymlweb: extends: file: common.yml service: webapp ports: - &quot;8000:8000&quot; links: - db environment: - DEBUG=truedb: image: postgres 后者会自动继承 common.yml 中的 webapp 服务及相关环节变量。 net设置网络模式。使用和 docker client 的 –net 参数一样的值。1234net: &quot;bridge&quot;net: &quot;none&quot;net: &quot;container:[name or id]&quot;net: &quot;host&quot; pid跟主机系统共享进程命名空间。打开该选项的容器可以相互通过进程 ID 来访问和操作。1pid: &quot;host&quot; dns配置 DNS 服务器。可以是一个值，也可以是一个列表。1234dns: 8.8.8.8dns: - 8.8.8.8 - 9.9.9.9 cap_add, cap_drop添加或放弃容器的 Linux 能力（Capabiliity）。123456cap_add: - ALLcap_drop: - NET_ADMIN - SYS_ADMIN dns_search配置 DNS 搜索域。可以是一个值，也可以是一个列表。1234dns_search: example.comdns_search: - domain1.example.com - domain2.example.com working_dir, entrypoint, user, hostname, domainname, mem_limit, privileged, restart, stdin_open, tty, cpu_shares这些都是和 docker run 支持的选项类似。12345678910111213141516cpu_shares: 73working_dir: /codeentrypoint: /code/entrypoint.shuser: postgresqlhostname: foodomainname: foo.commem_limit: 1000000000privileged: truerestart: alwaysstdin_open: truetty: true]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用命令]]></title>
    <url>%2Fdocker%2F%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[最好是查看docker文档 查看docker信息（version、info）12345# 查看docker版本 docker version # 显示docker系统的信息 docker info 对image的操作（search、pull、images、rmi、history）1234567891011121314# 检索image $docker search image_name # 下载image $docker pull image_name # 列出镜像列表; -a, --all=false Show all images; --no-trunc=false Don't truncate output; -q, --quiet=false Only show numeric IDs $docker images # 删除一个或者多个镜像; -f, --force=false Force; --no-prune=false Do not delete untagged parents $docker rmi image_name # 显示一个镜像的历史; --no-trunc=false Don't truncate output; -q, --quiet=false Only show numeric IDs $docker history image_name 启动容器（run）12345678$docker run image_name echo &quot;hello word&quot; # 交互式进入容器中 $docker run -i -t image_name /bin/bash # 在容器中安装新的程序 $docker run image_name apt-get install -y app_name 查看容器（ps）123456# 列出当前所有正在运行的container $docker ps # 列出所有的container $docker ps -a # 列出最近一次启动的container $docker ps -l 保存对容器的修改（commit）12# 保存对容器的修改; -a, --author=&quot;&quot; Author; -m, --message=&quot;&quot; Commit message $docker commit ID new_image_name 对容器的操作（rm、stop、start、kill、logs、diff、top、cp、restart、attach）1234567891011121314151617181920212223242526272829# 删除所有容器 $docker rm `docker ps -a -q` # 删除单个容器; -f, --force=false; -l, --link=false Remove the specified link and not the underlying container; -v, --volumes=false Remove the volumes associated to the container $docker rm Name/ID # 停止、启动、杀死一个容器 $docker stop Name/ID $docker start Name/ID $docker kill Name/ID # 从一个容器中取日志; -f, --follow=false Follow log output; -t, --timestamps=false Show timestamps $docker logs Name/ID # 列出一个容器里面被改变的文件或者目录，list列表会显示出三种事件，A 增加的，D 删除的，C 被改变的 $docker diff Name/ID # 显示一个运行的容器里面的进程信息 $docker top Name/ID # 从容器里面拷贝文件/目录到本地一个路径 $docker cp Name:/container_path to_path $docker cp ID:/container_path to_path # 重启一个正在运行的容器; -t, --time=10 Number of seconds to try to stop for before killing the container, Default=10 $docker restart Name/ID # 附加到一个运行的容器上面; --no-stdin=false Do not attach stdin; --sig-proxy=true Proxify all received signal to the process $docker attach ID 保存和加载镜像（save、load）12345678$docker save image_name -o file_path # 加载一个tar包格式的镜像; -i, --input=&quot;&quot; Read from a tar archive file $docker load -i file_path # 机器a $docker save image_name &gt; /home/save.tar # 使用scp将save.tar拷到机器b上，然后： $docker load &lt; /home/save.tar 登录registry server（login）12# 登陆registry server; -e, --email=&quot;&quot; Email; -p, --password=&quot;&quot; Password; -u, --username=&quot;&quot; Username $docker login 发布image（push）12# 发布docker镜像 $docker push new_image_name 根据Dockerfile 构建出一个容器（build）123456#build --no-cache=false Do not use cache when building the image -q, --quiet=false Suppress the verbose output generated by the containers --rm=true Remove intermediate containers after a successful build -t, --tag=&quot;&quot; Repository name (and optionally a tag) to be applied to the resulting image in case of success $docker build -t image_name Dockerfile_path]]></content>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pdf处理]]></title>
    <url>%2Flinux%2Fpdf%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[简介PDFtk 是什么？我觉得官网的一句话解释得很好。 If PDF is electronic paper, then PDFtk is an electronic staple-remover, hole-punch, binder, secret-decoder-ring, and X-Ray-glasses. PDFtk is a simple tool for doing everyday things with PDF documents. 其官方网站为：官网 PDFtk 目前分为三个版本： PDFtk Server：命令行工具。支持 windows、Linux、Mac。 PDFtk Free：图形界面基础免费版；仅限 windows 用户；功能仅限于 PDF 合并和分割； PDFtk Pro：图形界面专业收费版；仅限 windows 用户，可以对 PDF 文档进行合并、分割、旋转、加水印、加邮戳、加密。 对于 Linux 用户，唯一的选择是免费的 PDFtk Server，其功能与收费 PDFtk Pro 完全相同，只是没有 GUI 而已。作者还是很厚道的。 Linux 的各个发行版的官方源中基本都有该软件，直接 apt-get 或者 yum 安装即可。 功能合并 PDF；分割 PDF 页面；旋转 PDF 文档或页面；PDF 解密；（不是破解）PDF 加密；用 X/FDF 填写 PDF 表格；从 PDF 表格中生成 PDF Data Stencils；加背景水印或前景印章；报告 PDF Metrics，书签和元数据；增加 / 更新 PDF 书签或元数据；给 PDF 页面或文档加附件；解压 PDF 附件；分解 PDF 文档为多个单页；解压缩和重压缩页面流；修复受损的 PDF 文档；这功能完全可以与 Adobe Acrobat 相媲美了，更重要的是 PDFtk 支持 Linux 且完全免费。（个人用户免费，若用于商业用途需付费）。 用法示例具体选项看这里： 具体选项 下面给出一些常见的例子。例子原文 扫描一本书，odd.pdf 为书的全部奇数页，even.pdf 为书的全部偶数页，下面的命令可以将两个 pdf 合并成页码正常的书:1pdftk A=odd.pdf B=even.pdf shuffle A B output collated.pdf 如果 odd.pdf 是逆序的:1pdftk A=odd.pdf B=even.pdf shuffle Aend-1 B output collated.pdf 加密 PDF:1pdftk secured.pdf input_pw foopass output unsecured.pdf PDF 128 位加密，保留全部权限:1pdftk 1.pdf output 1.128.pdf owner_pw foopass PDF 128 位加密，保留全部权限，打开文档需输入密码 “baz”:1pdftk 1.pdf output 1.128.pdf owner_pw foo user_pw baz PDF 128 位加密，打开文档需输入密码 “baz”，保留打印之外的其他权限:1pdftk 1.pdf output 1.128.pdf owner_pw foo user_pw baz allow printing 合并 in1.pdf 和 in2.pdf 到新 PDF 中:1pdftk in1.pdf in2.pdf cat output out1.pdf 或（使用句柄）:1pdftk A=in1.pdf B=in2.pdf cat A B output out1.pdf 或（使用通配符）:1pdftk *.pdf cat output combined.pdf 去除 in1.pdf 中的第 13 页，并创建 out1.pdf:1pdftk in.pdf cat 1-12 14-end output out1.pdf 或1pdftk A=in1.pdf cat A1-12 A14-end output out1.pdf 对输出进行 40 位加密，撤销所有权限，设置 owner 密码为 foopass:1pdftk 1.pdf 2.pdf cat output 3.pdf encrypt_40bit owner_pw foopass 合并两个文件，其中一个需要被加密。对输出不加密:1pdftk A=secured.pdf 2.pdf input_pw A=foopass cat output 3.pdf 解压 PDF 页面流，然后就可以在文本编辑器中编辑 PDF 文件:1pdftk doc.pdf output doc.unc.pdf uncompress 压缩 PDF:1pdftk mydoc.pdf output mydoc.clear.pdf compress 修复破损的 PDF:1pdftk broken.pdf output fixed.pdf 将一个 PDF 文档分割成一页一个文档:1pdftk in.pdf burst 将一个 PDF 文档分割成一页一个文档，并加密，允许低质量的打印:1pdftk in.pdf burst owner_pw foopass allow DegradedPrinting 获取 PDF 问的元数据和书签信息:1pdftk in.pdf dump_data output report.txt 将 PDF 第一页顺时针旋转 90 度:1pdftk in.pdf cat 1east 2-end output out.pdf 将整个 PDF 文档旋转 180 度:1pdftk in.pdf cat 1-endsouth output out.pdf]]></content>
      <tags>
        <tag>linux</tag>
        <tag>pdf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[shell]]></title>
    <url>%2Flinux%2Fshell%2F</url>
    <content type="text"><![CDATA[判断命令是否执行成功1234567if [[ $? -eq 0 ]];then A else b;fi# 或if [ $? -eq 0 ];then 命令正确的分支else 命令失败的分支fi 在脚本中执行其他脚本 fork ( /directory/script.sh)： 如果shell中包含执行命令，那么子命令并不影响父级的命令，在子命令执行完后再执行父级命令。子级的环境变量不会影响到父级。fork是最普通的, 就是直接在脚本里面用/directory/script.sh来调用script.sh这个脚本.运行的时候开一个sub-shell执行调用的脚本，sub-shell执行的时候, parent-shell还在。sub-shell执行完毕后返回parent-shell. sub-shell从parent-shell继承环境变量.但是sub-shell中的环境变量不会带回parent-shell exec (exec /directory/script.sh)： 执行子级的命令后，不再执行父级命令。exec与fork不同，不需要新开一个sub-shell来执行被调用的脚本. 被调用的脚本与父脚本在同一个shell内执行。但是使用exec调用一个新脚本以后, 父脚本中exec行之后的内容就不会再执行了。这是exec和source的区别 source (source /directory/script.sh)： 执行子级命令后继续执行父级命令，同时子级设置的环境变量会影响到父级的环境变量。与fork的区别是不新开一个sub-shell来执行被调用的脚本，而是在同一个shell中执行. 所以被调用的脚本中声明的变量和环境变量, 都可以在主脚本中得到和使用. 获取时间12file_name=&quot;`date +%y%m%d`.sql&quot;# 结果：170109.sql 参数12# 将参数赋值给file_name变量，注意=两边不能有空格file_name=$1]]></content>
      <tags>
        <tag>linux</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vim]]></title>
    <url>%2Flinux%2Fvim%2F</url>
    <content type="text"><![CDATA[移动光标 ctrl+b: 前移一个字符(backward) ctrl+f: 后移一个字符(forward) alt+&lt;-: 前移一个单词 alt+-&gt;: 后移一个单词 ctrl+a: 移到行首（a是首字母） ctrl+e: 移到行尾（end） ctrl+x: 行首到当前光标替换 编辑命令 alt+.: 粘帖最后一次命令最后的参数（通常用于mkdir long-long-dir后, cd配合着alt+.） alt+d: 删除当前光标到临近右边单词开始(delete) ctrl+w: 删除当前光标到临近左边单词结束(word) ctrl+h: 删除光标前一个字符（相当于backspace） ctrl+d: 删除光标后一个字符（相当于delete） ctrl+u: 删除光标左边所有 ctrl+k: 删除光标右边所有 ctrl+l: 清屏 ctrl+shift+c: 复制（相当于鼠标左键拖拽） ctrl+shift+v: 粘贴（相当于鼠标中键） 其它 ctrl+n: 下一条命令 ctrl+p: 上一条命令 alt+n: 下一条命令（例如输入ls, 然后按’alt+n’, 就会找到历史记录下的ls命令） alt+p: 上一条命令（跟alt+n相似） shift+PageUp: 向上翻页 shift+PageDown: 向下翻页 ctrl+r: 进入历史查找命令记录， 输入关键字。 多次按返回下一个匹配项 zsh d: 列出以前的打开的命令 j: jump到以前某个目录，模糊匹配 Vim移动光标 b: 向前移动一个单词 w: 向后移动一个单词 删除 dw: 从当前光标开始删除到下一个单词头 de: 从当前光标开始删除到单词尾]]></content>
      <tags>
        <tag>linux</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mongo聚合]]></title>
    <url>%2Fmongodb%2Fmongo%E8%81%9A%E5%90%88%2F</url>
    <content type="text"><![CDATA[分组统计shell语法根据等级分组统计1&gt; db.users.aggregate([&#123;"$group":&#123;"_id":"bookLevel", "count":&#123;"$sum":1&#125;&#125;&#125;]) 根据引导分组统计1&gt; db.users.aggregate([&#123;"$group":&#123;"_id":&#123;"guide":"$guide", "guideTwo":"$guideTwo"&#125;, "count":&#123;"$sum":1&#125;&#125;&#125;]) mgo语法12345678910111213141516// LevelCount 用户等级分布type LevelCount struct &#123; Level int `bson:"_id"` Count int `bson:"count"`&#125;var counts []LevelCountmongoInstance := db.GetInstance()defer mongoInstance.Close()collection := mongoInstance.GetCollection(UsersKey)m := []bson.M&#123; &#123;"$group": bson.M&#123;"_id": "$bookLevel", "count": bson.M&#123;"$sum": 1&#125;&#125;&#125;,&#125;err = collection.Pipe(m).All(&amp;counts)if err != nil &#123; return&#125;]]></content>
      <tags>
        <tag>mongo</tag>
        <tag>aggregate</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CRUD操作]]></title>
    <url>%2Fmongodb%2FCRUD%2F</url>
    <content type="text"><![CDATA[insert 正常插入： 12&gt; db.user.insert(&#123;x:1,y:2,z:3&#125;)WriteResult(&#123; "nInserted" : 1 &#125;) 循环插入 12&gt; for(var i=1;i&lt;100;i++) db.user.insert(&#123;x:i, y:i*10, z:i*100&#125;)WriteResult(&#123; "nInserted" : 1 &#125;) update 整个更新 12345678&gt; db.user.find()&#123; "_id" : ObjectId("58d0d844bae387d0c1e8d870"), "x" : 1, "y" : 2 &#125;&#123; "_id" : ObjectId("58d0d84ebae387d0c1e8d871"), "x" : 2, "y" : 3 &#125;&gt; db.user.update(&#123;x:1&#125;,&#123;x:999&#125;)WriteResult(&#123; "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 &#125;)&gt; db.user.find()&#123; "_id" : ObjectId("58d0d844bae387d0c1e8d870"), "x" : 999 &#125;&#123; "_id" : ObjectId("58d0d84ebae387d0c1e8d871"), "x" : 2, "y" : 3 &#125; 部分更新使用$set操作符 12345678&gt; db.user.find()&#123; "_id" : ObjectId("58d0d844bae387d0c1e8d870"), "x" : 999 &#125;&#123; "_id" : ObjectId("58d0d84ebae387d0c1e8d871"), "x" : 2, "y" : 3 &#125;&gt; db.user.update(&#123;x:2&#125;,&#123;$set:&#123;x:999&#125;&#125;)WriteResult(&#123; "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 &#125;)&gt; db.user.find()&#123; "_id" : ObjectId("58d0d844bae387d0c1e8d870"), "x" : 999 &#125;&#123; "_id" : ObjectId("58d0d84ebae387d0c1e8d871"), "x" : 999, "y" : 3 &#125; 不存在则创建 123456789101112&gt; db.user.find(&#123;x:1&#125;)&gt; db.user.update(&#123;x:1&#125;,&#123;x:2&#125;,true)WriteResult(&#123; "nMatched" : 0, "nUpserted" : 1, "nModified" : 0, "_id" : ObjectId("58d0da6e34123eac45d857ac")&#125;)&gt; db.user.find()&#123; "_id" : ObjectId("58d0d844bae387d0c1e8d870"), "x" : 999 &#125;&#123; "_id" : ObjectId("58d0d84ebae387d0c1e8d871"), "x" : 999, "y" : 3 &#125;&#123; "_id" : ObjectId("58d0da6e34123eac45d857ac"), "x" : 2 &#125; 更新多条mongodb默认是更新一条，据说是为了防止一时大意，而且更新多条不允许更新整个，只能使用$set关键字 12345678910&gt; db.user.find()&#123; "_id" : ObjectId("58d0dde9bae387d0c1e8d873"), "x" : 1, "y" : 2, "z" : 1 &#125;&#123; "_id" : ObjectId("58d0ddeabae387d0c1e8d874"), "x" : 1, "y" : 1, "z" : 1 &#125;&#123; "_id" : ObjectId("58d0ddebbae387d0c1e8d875"), "x" : 1, "y" : 1, "z" : 1 &#125;&gt; db.user.update(&#123;x:1&#125;,&#123;$set:&#123;y:2&#125;&#125;,false,true)WriteResult(&#123; "nMatched" : 3, "nUpserted" : 0, "nModified" : 2 &#125;)&gt; db.user.find()&#123; "_id" : ObjectId("58d0dde9bae387d0c1e8d873"), "x" : 1, "y" : 2, "z" : 1 &#125;&#123; "_id" : ObjectId("58d0ddeabae387d0c1e8d874"), "x" : 1, "y" : 2, "z" : 1 &#125;&#123; "_id" : ObjectId("58d0ddebbae387d0c1e8d875"), "x" : 1, "y" : 2, "z" : 1 &#125; remove 删除某个collection所有内容 12&gt; db.user.remove(&#123;&#125;)WriteResult(&#123; "nRemoved" : 102 &#125;) 删除某个 12&gt; db.user.remove(&#123;x:3&#125;)WriteResult(&#123; "nRemoved" : 1 &#125;) find 查找所有 1234&gt; db.user.find()&#123; "_id" : ObjectId("58d0cebcbae387d0c1e8d80a"), "username" : "zhangsan" &#125;&#123; "_id" : ObjectId("58d0d36abae387d0c1e8d80b"), "x" : 1, "y" : 2, "z" : 3 &#125;&#123; "_id" : ObjectId("58d0d37dbae387d0c1e8d80c"), "x" : 1, "y" : 2, "z" : 3 &#125; 有条件查找 123&gt; db.user.find(&#123;x:1&#125;)&#123; "_id" : ObjectId("58d0d36abae387d0c1e8d80b"), "x" : 1, "y" : 2, "z" : 3 &#125;&#123; "_id" : ObjectId("58d0d37dbae387d0c1e8d80c"), "x" : 1, "y" : 2, "z" : 3 &#125; 查找总数目 12&gt; db.user.find().count()102 分页,排序 1234&gt; db.user.find().skip(5).limit(3).sort(&#123;x:1&#125;)&#123; "_id" : ObjectId("58d0d453bae387d0c1e8d80f"), "x" : 3, "y" : 30, "z" : 300 &#125;&#123; "_id" : ObjectId("58d0d453bae387d0c1e8d810"), "x" : 4, "y" : 40, "z" : 400 &#125;&#123; "_id" : ObjectId("58d0d453bae387d0c1e8d811"), "x" : 5, "y" : 50, "z" : 500 &#125;]]></content>
      <tags>
        <tag>mongo</tag>
        <tag>auth</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[auth认证]]></title>
    <url>%2Fmongodb%2Fauth%2F</url>
    <content type="text"><![CDATA[以auth认证方式启动 可以在config文件中加一项： 1auth: true 可以在命令行中，添加一个option，--auth 但是，如果mongodb中没有用户，认证是没有意义的。 创建用户 选择库 12// 用户的存储也是基于库的。管理员用户的话，需要在admin中创建。创建的第一个用户即为管理员用户&gt; use admin 创建管理员用户 12345678910db.createUser(&#123; user:&quot;root&quot;, pwd:&quot;root&quot;, roles:[ &#123; role:&quot;userAdminAnyDatabase&quot;, db:&quot;admin&quot; &#125; ]&#125;) 创建普通用户 12345678910db.createUser(&#123; user:"user1", pwd:"pwd1", roles:[ &#123; role:"readWrite", db:"db1" &#125; ]&#125;) 登录方式112345// user所存储的库&gt; use admin&gt; db.auth(username, password)// 返回原数据库&gt; use blog 方式21&gt; mongo --host ip:port -u 用户 -p 密码 --authenticationDatabase admin mongodb配置文件相关参数1234567891011121314151617181920#数据库数据存放目录dbpath=/usr/local/mongodb304/data#数据库日志存放目录logpath=/usr/local/mongodb304/logs/mongodb.log #以追加的方式记录日志logappend = true#端口号 默认为27017port=27017 #以后台方式运行进程fork=true #开启用户认证auth=true#关闭http接口，默认关闭http端口访问nohttpinterface=true#mongodb所绑定的ip地址bind_ip = 127.0.0.1,192.168.1.140#启用日志文件，默认启用journal=true #这个选项可以过滤掉一些无用的日志信息，若需要调试使用请设置为falsequiet=true]]></content>
      <tags>
        <tag>mongo</tag>
        <tag>auth</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数]]></title>
    <url>%2Fmysql%2F%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[concat1234// 将id name work_date连接起来CONCAT(id, name, work_date)// 在like中用到：CONCAT('%',:v" . self::$number . ",'%')]]></content>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基本设置]]></title>
    <url>%2Fnginx%2F%E5%9F%BA%E6%9C%AC%E8%AE%BE%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[只允许本机访问一般用于设置内部服务器12345678910111213server &#123; listen 8888; server_name localhost; root /www/vux/vux/my; location / &#123; allow 127.0.0.1; deny all; try_files $uri $uri/ /index.php?$query_string; autoindex on; index index.html index.htm index.php; include /etc/nginx/conf.d/php-fpm; &#125;&#125; 域名（端口）转发一般用于前后端完全分离的设计1234567891011121314151617181920server &#123; listen 80; server_name douniu.kouhuo.site; location / &#123; index index.html index.htm index.php; proxy_redirect off; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://127.0.0.1:8080; &#125; location /api &#123; #rewrite ^.+api/?(.*)$ /$1 break; proxy_redirect off; proxy_set_header Host $host; #要转发的host proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://127.0.0.1:8888/; #设置要转发的ip（域名）端口 &#125;&#125; 访问php动态资源(fastcgi)1234567891011121314151617181920212223242526server &#123; listen 80; server_name local.ladmin.com local.ladmin.com; root &quot;D:/items/laravel/lesson-admin/public&quot;; index index.html index.htm index.php; location / &#123; try_files $uri $uri/ /index.php?$query_string; #autoindex on; &#125; location ~ \.php(.*)$ &#123; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; fastcgi_split_path_info ^((?U).+\.php)(/?.+)$; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_param PATH_INFO $fastcgi_path_info; fastcgi_param PATH_TRANSLATED $document_root$fastcgi_path_info; include fastcgi_params; add_header Access-Control-Allow-Origin *; add_header Access-Control-Allow-Methods &quot;POST, GET, OPTIONS&quot;; add_header Access-Control-Allow-Credentials &quot;true&quot;; add_header Access-Control-Allow-Headers &quot;Accept,Authorization,Cache-Control,Content-Type,DNT,If-Modified-Since,Keep-Alive,Origin,User-Agent,X-Mx-ReqToken,X-Requested-With&quot;; if ($request_method = &apos;OPTIONS&apos;)&#123; return 204; &#125; &#125;&#125; 配置header头的最大字节数1234567server&#123; ... proxy_buffer_size 128k; proxy_buffers 4 256k; proxy_busy_buffers_size 256k; ...&#125; 设置超时时间1234567server&#123; ... proxy_connect_timeout 360; proxy_send_timeout 360; proxy_read_timeout 360; ...&#125;]]></content>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rewrite 规则]]></title>
    <url>%2Fnginx%2Frewrite%E8%A7%84%E5%88%99%2F</url>
    <content type="text"><![CDATA[1. location正则写法 示例：123456789101112131415161718192021222324252627282930313233343536373839404142location = / &#123; # 精确匹配 / ，主机名后面不能带任何字符串 [ configuration A ]&#125;location / &#123; # 因为所有的地址都以 / 开头，所以这条规则将匹配到所有请求 # 但是正则和最长字符串会优先匹配 [ configuration B ]&#125;location /documents/ &#123; # 匹配任何以 /documents/ 开头的地址，匹配符合以后，还要继续往下搜索 # 只有后面的正则表达式没有匹配到时，这一条才会采用这一条 [ configuration C ]&#125;location ~ /documents/Abc &#123; # 匹配任何以 /documents/Abc 开头的地址，匹配符合以后，还要继续往下搜索 # 只有后面的正则表达式没有匹配到时，这一条才会采用这一条 [ configuration CC ]&#125;location ^~ /images/ &#123; # 匹配任何以 /images/ 开头的地址，匹配符合以后，停止往下搜索正则，采用这一条。 [ configuration D ]&#125;location ~* \.(gif|jpg|jpeg)$ &#123; # 匹配所有以 gif,jpg或jpeg 结尾的请求 # 然而，所有请求 /images/ 下的图片会被 config D 处理，因为 ^~ 到达不了这一条正则 [ configuration E ]&#125;location /images/ &#123; # 字符匹配到 /images/，继续往下，会发现 ^~ 存在 [ configuration F ]&#125;location /images/abc &#123; # 最长字符匹配到 /images/abc，继续往下，会发现 ^~ 存在 # F与G的放置顺序是没有关系的 [ configuration G ]&#125;location ~ /images/abc/ &#123; # 只有去掉 config D 才有效：先最长匹配 config G 开头的地址，继续往下搜索，匹配到这一条正则，采用 [ configuration H ]&#125;location ~* /js/.*/\.js 已=开头表示精确匹配如 A 中只匹配根目录结尾的请求，后面不能带任何字符串。 ^~ 开头表示uri以某个常规字符串开头，不是正则匹配 ~ 开头表示区分大小写的正则匹配; ~* 开头表示不区分大小写的正则匹配 / 通用匹配, 如果没有其它匹配,任何请求都会匹配到 顺序 no优先级：(location =) &gt; (location 完整路径) &gt; (location ^~ 路径) &gt; (location ~,~* 正则顺序) &gt; (location 部分起始路径) &gt; (/)]]></content>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
</search>
